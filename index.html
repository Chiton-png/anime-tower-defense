<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Anime Roguelike Shooter</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      background:#050509;
      color:#f5f5f5;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:10px;
      user-select:none;
    }
    h1{font-size:22px;margin-bottom:4px}
    p{font-size:12px;margin-bottom:6px;opacity:.85}

    #container{position:relative;display:inline-block}
    #game{
      display:block;
      border-radius:8px;
      border:2px solid #333;
      background:#000;
      image-rendering:pixelated;
    }
    #overlayMessage{
      position:absolute;
      top:8px;
      left:50%;
      transform:translateX(-50%);
      padding:4px 10px;
      background:rgba(0,0,0,.6);
      border-radius:999px;
      font-size:12px;
      pointer-events:none;
    }

    #hud{
      margin-top:6px;
      font-size:13px;
      display:flex;
      gap:12px;
      justify-content:center;
      flex-wrap:wrap;
    }
    #hudHP.low{
      color:#ff7070;
      text-shadow:0 0 8px rgba(255,90,90,.9);
    }
    #hudUlt.ult-ready{
      color:#ffe08a;
      text-shadow:0 0 8px rgba(255,210,120,.9);
    }
    #hudStyle.style-high{
      color:#87c7ff;
      text-shadow:0 0 8px rgba(120,180,255,.9);
    }

    #upgradePanel{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.75);
      z-index:10;
    }
    #upgradePanelInner{
      background:#101010;
      border-radius:10px;
      padding:14px;
      max-width:620px;
      width:92%;
      box-shadow:0 0 24px rgba(0,0,0,.9);
      font-size:13px;
    }
    #upgradePanelInner h2{margin-bottom:6px;font-size:18px}
    #upgradePanelInner p{margin-bottom:8px;font-size:11px;opacity:.9}
    #upgrades{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:6px;
    }
    .upgradeButton{
      background:#181818;
      border-radius:6px;
      padding:7px;
      text-align:left;
      cursor:pointer;
      font-size:12px;
      border:1px solid #555;
      color:#f5f5f5;
      transition:background .1s,transform .05s,box-shadow .1s,border-color .1s;
    }
    .upgradeButton:hover{
      background:#252525;
      transform:translateY(-1px);
      box-shadow:0 0 16px rgba(255,255,255,.16);
    }
    .upgradeTopRow{
      display:flex;
      justify-content:space-between;
      margin-bottom:2px;
    }
    .upgradeName{font-weight:600}
    .upgradeDesc{font-size:11px;opacity:.92;color:#f0f0f0}

    .rarityBadge{
      font-size:9px;
      padding:2px 6px;
      border-radius:999px;
      text-transform:uppercase;
      letter-spacing:.05em;
      font-weight:600;
      border:1px solid transparent;
    }
    .rarity-common{
      color:#b8f7b8;
      background:rgba(80,160,80,.18);
      border-color:rgba(120,220,120,.7);
    }
    .rarity-rare{
      color:#87c7ff;
      background:rgba(80,120,200,.18);
      border-color:rgba(120,180,255,.7);
    }
    .rarity-epic{
      color:#e3b3ff;
      background:rgba(150,80,200,.2);
      border-color:rgba(210,150,255,.8);
    }
    .rarity-legendary{
      color:#ffe08a;
      background:rgba(200,140,40,.25);
      border-color:rgba(255,206,120,.9);
    }

    .card-rarity-common{
      box-shadow:0 0 6px rgba(130,220,130,.5);
      border-color:rgba(130,220,130,.7);
    }
    .card-rarity-rare{
      box-shadow:0 0 9px rgba(120,180,255,.7);
      border-color:rgba(120,180,255,.9);
    }
    .card-rarity-epic{
      box-shadow:0 0 11px rgba(210,140,255,.8);
      border-color:rgba(210,140,255,1);
    }
    .card-rarity-legendary{
      box-shadow:0 0 14px rgba(255,210,100,1);
      border-color:rgba(255,210,100,1);
    }

    #skipButton,
    #rerollButton{
      margin-top:2px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid #777;
      background:#222;
      color:#f5f5f5;
      cursor:pointer;
      font-size:11px;
    }
    #skipButton:hover,
    #rerollButton:hover{background:#333}
    #rerollButton[disabled]{
      opacity:0.4;
      cursor:not-allowed;
      box-shadow:none;
    }

    #abilitiesBar{
      margin-top:8px;
      display:flex;
      gap:20px;
      justify-content:center;
      flex-wrap:wrap;
      max-width:960px;
      font-size:11px;
    }
    .abilitiesGroup{
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-start;
    }
    .abilitiesTitle{opacity:.75;font-size:11px}
    .abilitiesList{
      display:flex;
      gap:4px;
      flex-wrap:wrap;
      max-width:460px;
    }
    .abilitySlot{
      border-radius:999px;
      padding:3px 7px;
      border:1px solid #666;
      background:#151515;
      font-size:10px;
      cursor:pointer;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      transition:background .1s,transform .05s,box-shadow .1s,border-color .1s;
    }
    .abilitySlot:hover{
      background:#232323;
      transform:translateY(-1px);
    }
    .abilitySlot.card-rarity-common{
      box-shadow:0 0 4px rgba(130,220,130,.5);
      border-color:rgba(130,220,130,.7);
    }
    .abilitySlot.card-rarity-rare{
      box-shadow:0 0 6px rgba(120,180,255,.7);
      border-color:rgba(120,180,255,.9);
    }
    .abilitySlot.card-rarity-epic{
      box-shadow:0 0 7px rgba(210,140,255,.8);
      border-color:rgba(210,140,255,1);
    }
    .abilitySlot.card-rarity-legendary{
      box-shadow:0 0 9px rgba(255,210,100,1);
      border-color:rgba(255,210,100,1);
    }

    /* MAIN MENU */
    #mainMenu{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.9);
      z-index:20;
    }
    #mainMenuInner{
      background:#111;
      padding:16px 20px;
      border-radius:10px;
      max-width:720px;
      width:92%;
      box-shadow:0 0 24px rgba(0,0,0,.9);
      text-align:left;
      font-size:13px;
    }
    #mainMenuInner h2{margin-bottom:4px;font-size:20px}
    #mainMenuInner p{opacity:.85;margin-bottom:6px;font-size:11px}

    .mainMenuTabsRow{
      display:flex;
      gap:8px;
      margin:8px 0 6px 0;
      flex-wrap:wrap;
    }
    .mainMenuSection{
      margin-top:6px;
      padding-top:4px;
      border-top:1px solid #222;
    }
    .menuButtons{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin:6px 0;
    }
    .menuButton{
      padding:7px 12px;
      border-radius:999px;
      border:1px solid #666;
      background:#222;
      color:#f5f5f5;
      cursor:pointer;
      font-size:12px;
      transition:background .1s,transform .05s,box-shadow .1s;
    }
    .menuButton:hover{
      background:#333;
      transform:translateY(-1px);
      box-shadow:0 0 12px rgba(255,255,255,.15);
    }
    .menuButton.styleActive{
      background:#203040;
      border-color:#7bd0ff;
      box-shadow:0 0 12px rgba(123,208,255,.8);
    }
    .menuButton.cosmeticLocked{
      opacity:0.35;
      border-style:dashed;
      cursor:not-allowed;
      box-shadow:none;
    }
    .menuButton.cosmeticSelected{
      box-shadow:0 0 12px rgba(255,255,255,0.5);
    }

    .menuSectionTitle{
      margin-top:4px;
      margin-bottom:2px;
      font-weight:600;
      font-size:11px;
      opacity:.9;
      text-transform:uppercase;
      letter-spacing:.05em;
    }
    .menuHint{
      margin-top:4px;
      font-size:10px;
      opacity:.7;
    }

    .settingsRow{
      display:flex;
      flex-direction:column;
      gap:2px;
      margin-bottom:6px;
      padding:5px 6px;
      border-radius:6px;
      background:#181818;
      border:1px solid #333;
    }
    .settingsRow label{
      font-size:12px;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .settingsRow span{
      font-size:10px;
      opacity:.78;
      padding-left:18px;
    }
    .settingsRow input[type="checkbox"]{
      width:14px;
      height:14px;
      accent-color:#7bd0ff;
    }

    .achievementsList{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-top:4px;
      max-height:220px;
      overflow-y:auto;
      padding-right:4px;
    }
    .achievementItem{
      padding:6px 8px;
      border-radius:6px;
      background:#181818;
      border:1px solid #333;
      font-size:11px;
    }
    .achievementItem.achieved{
      border-color:#7bd0ff;
      box-shadow:0 0 10px rgba(123,208,255,0.35);
    }
    .achievementName{
      font-weight:600;
      margin-bottom:2px;
    }
    .achievementDesc{
      opacity:.8;
      margin-bottom:2px;
    }
    .achievementProgress{
      font-size:10px;
      opacity:.8;
    }

    /* LAYOUT WITH STATS PANEL */
    #pageRow{
      margin-top:6px;
      display:flex;
      align-items:flex-start;
      gap:16px;
      max-width:1220px;
    }
    #leftColumn{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
    }
    #statsPanel{
      min-width:210px;
      max-width:230px;
      padding:8px 10px;
      border-radius:8px;
      background:rgba(10,10,20,0.95);
      border:1px solid #333;
      box-shadow:0 0 18px rgba(0,0,0,0.8);
      font-size:11px;
    }
    #statsPanel h3{
      font-size:13px;
      margin-bottom:4px;
      text-align:left;
      letter-spacing:0.04em;
      text-transform:uppercase;
      opacity:0.85;
    }
    #statsContent{
      display:flex;
      flex-direction:column;
      gap:2px;
      max-height:480px;
      overflow-y:auto;
      padding-right:2px;
    }
    .statRow{
      display:flex;
      justify-content:space-between;
      gap:6px;
    }
    .statRow span:first-child{opacity:0.7}
    .statRow span:last-child{font-weight:600}

    /* MOBILE CONTROLS */
    #mobileControls{
      position:fixed;
      bottom:10px;
      left:0;
      right:0;
      display:none;
      justify-content:space-between;
      padding:0 12px;
      pointer-events:none;
      z-index:30;
    }
    .mobileGroup{
      display:flex;
      gap:8px;
      pointer-events:auto;
    }
    .mobileDpad{
      display:grid;
      grid-template-columns:repeat(3,36px);
      grid-template-rows:repeat(3,36px);
      gap:4px;
    }
    .mobileBtn{
      border-radius:999px;
      border:1px solid #555;
      background:rgba(20,20,30,0.92);
      color:#f5f5f5;
      font-size:12px;
      padding:4px;
      cursor:pointer;
    }
    .mobileBtn:active{background:#444}
    .mobileBtn.empty{visibility:hidden}
    @media (min-width:900px){
      #mobileControls{display:none!important;}
    }
  </style>
</head>
<body>
  <h1>Anime Roguelike Shooter</h1>
  <p>WASD / Arrows move • Mouse aim • Left click shoot • Right click / E melee • Space dash • Q ultimate • R restart</p>

  <!-- MAIN MENU -->
  <div id="mainMenu">
    <div id="mainMenuInner">
      <h2>Anime Rogue Run</h2>
      <p>Build insane anime runs: Demon Slayer, One Piece, JJK, MHA, Cyberpunk, Solo Leveling, etc.</p>

      <div class="mainMenuTabsRow">
        <button class="menuButton mainTabButton styleActive" data-tab="playTab">Play</button>
        <button class="menuButton mainTabButton" data-tab="settingsTab">Settings</button>
        <button class="menuButton mainTabButton" data-tab="achievementsTab">Achievements</button>
        <button class="menuButton mainTabButton" data-tab="cosmeticsTab">Cosmetics</button>
      </div>

      <!-- PLAY TAB -->
      <div id="playTab" class="mainMenuSection">
        <p class="menuHint">Choose difficulty, playstyle and ultimate – then dive into waves and bosses.</p>

        <p class="menuSectionTitle">Mode</p>
        <div class="menuButtons">
          <button class="menuButton modeButton" data-mode="chill">Chill</button>
          <button class="menuButton modeButton styleActive" data-mode="normal">Normal</button>
          <button class="menuButton modeButton" data-mode="cursed">Cursed</button>
        </div>

        <p class="menuSectionTitle">Combat Style</p>
        <div class="menuButtons">
          <button class="menuButton" data-style="melee">Melee Focus</button>
          <button class="menuButton" data-style="ranged">Ranged Focus</button>
        </div>

        <p class="menuSectionTitle">Archetype</p>
        <div class="menuButtons">
          <button class="menuButton archButton" data-arch="swordsman">Sharp Swordsman</button>
          <button class="menuButton archButton styleActive" data-arch="sorcerer">Cursed Sorcerer</button>
          <button class="menuButton archButton" data-arch="titan">Titan Slayer</button>
          <button class="menuButton archButton" data-arch="hero">Quirked Hero</button>
        </div>

        <p class="menuSectionTitle">Ultimate (Q / mobile button)</p>
        <div class="menuButtons" id="ultMenu">
          <button class="menuButton ultButton styleActive" data-ult="jjk_domain">JJK Domain</button>
          <button class="menuButton ultButton" data-ult="ofa_100">OFA 100%</button>
          <button class="menuButton ultButton" data-ult="demon_mark">Demon Mark</button>
          <button class="menuButton ultButton" data-ult="gear_fifth">Gear Fifth</button>
          <button class="menuButton ultButton" data-ult="susanoo_guardian">Susanoo Guardian</button>
          <button class="menuButton ultButton" data-ult="cyber_sandevistan">Cyber Sandevistan</button>
          <button class="menuButton ultButton" data-ult="ghoul_rampage">Ghoul Rampage</button>
          <button class="menuButton ultButton" data-ult="flame_domain">Flame Ring</button>
          <button class="menuButton ultButton" data-ult="bankai_field">Bankai Field</button>
          <button class="menuButton ultButton" data-ult="haki_burst">Haki Burst</button>
          <button class="menuButton ultButton" data-ult="chimera_shadow_garden">Chimera Shadow Garden</button>
          <button class="menuButton ultButton" data-ult="thunder_god_avatar">Thunder God Avatar</button>
          <button class="menuButton ultButton" data-ult="orbital_strike">Orbital Strike</button>
        </div>

        <p class="menuSectionTitle">Power Info</p>
        <p class="menuHint">
          Normal powers: max <b>5</b>. Boss & curse powers: max <b>2</b>.<br>
          Curses are Legendary and only appear on <b>boss waves</b>. Every boss wave shows at least one Legendary and one Curse.<br>
          Wave challenges can give you <b>rerolls</b> for power choices.
        </p>

        <div class="menuButtons" style="margin-top:10px;justify-content:flex-start;">
          <button id="startRunButton" class="menuButton" style="padding:8px 20px;font-weight:600;">Start Run</button>
        </div>

        <p class="menuHint">
          Powers every wave with drawbacks. Boss & curse options every 5 waves. Summons, dashes, domains and broken builds.
        </p>
      </div>

      <!-- SETTINGS TAB -->
      <div id="settingsTab" class="mainMenuSection" style="display:none;">
        <p class="menuHint">Tweaks that affect feel and comfort.</p>

        <div class="settingsRow">
          <label><input type="checkbox" id="settingScreenShake" checked> Screen shake</label>
          <span>Impact shake on hits, dashes and explosions.</span>
        </div>

        <div class="settingsRow">
          <label><input type="checkbox" id="settingLowFlash"> Reduce flashes</label>
          <span>Dim white flashes on ults and big hits.</span>
        </div>

        <div class="settingsRow">
          <label><input type="checkbox" id="settingShowHints" checked> Show hint popups</label>
          <span>Small text at the top for events, bosses and tips.</span>
        </div>

        <p class="menuHint">
          Settings are saved locally on this device.
        </p>
      </div>

      <!-- ACHIEVEMENTS TAB -->
      <div id="achievementsTab" class="mainMenuSection" style="display:none;">
        <p class="menuHint">Milestones from your previous runs. Some unlock cosmetics.</p>
        <div id="achievementsList" class="achievementsList"></div>
      </div>

      <!-- COSMETICS TAB -->
      <div id="cosmeticsTab" class="mainMenuSection" style="display:none;">
        <p class="menuSectionTitle">Cosmetics – Player Skin</p>
        <div class="menuButtons" id="skinMenu">
          <button class="menuButton skinButton" data-skin="skin_default">Default Hunter</button>
          <button class="menuButton skinButton" data-skin="skin_hashira">Hashira Cloak</button>
          <button class="menuButton skinButton" data-skin="skin_domain_freak">Domain Freak</button>
          <button class="menuButton skinButton" data-skin="skin_shadow_monarch">Shadow Monarch</button>
          <button class="menuButton skinButton" data-skin="skin_flame_hashira">Flame Hashira</button>
          <button class="menuButton skinButton" data-skin="skin_sukuna_king">King of Curses</button>
          <button class="menuButton skinButton" data-skin="skin_apex_legend">Apex Operator</button>
        </div>

        <p class="menuSectionTitle">Cosmetics – Bullet Trail</p>
        <div class="menuButtons" id="trailMenu">
          <button class="menuButton trailButton" data-trail="trail_default">Default Trail</button>
          <button class="menuButton trailButton" data-trail="trail_flame">Flame Rounds</button>
          <button class="menuButton trailButton" data-trail="trail_cursed">Cursed Sparks</button>
          <button class="menuButton trailButton" data-trail="trail_lightning">Lightning Shots</button>
          <button class="menuButton trailButton" data-trail="trail_blood">Blood Rounds</button>
          <button class="menuButton trailButton" data-trail="trail_void">Void Rounds</button>
        </div>

        <p class="menuSectionTitle">Cosmetics – Dash Trail</p>
        <div class="menuButtons" id="dashMenu">
          <button class="menuButton dashButton" data-dash="dash_default">Default Dash</button>
          <button class="menuButton dashButton" data-dash="dash_afterimage">Afterimage Step</button>
          <button class="menuButton dashButton" data-dash="dash_void">Void Step</button>
          <button class="menuButton dashButton" data-dash="dash_flame">Flame Dash</button>
          <button class="menuButton dashButton" data-dash="dash_cursed">Cursed Dash</button>
        </div>

        <p class="menuHint">
          Locked cosmetics are greyed out – unlock them by hitting milestones in your runs.
        </p>
      </div>
    </div>
  </div>

  <div id="pageRow">
    <div id="leftColumn">
      <div id="container">
        <canvas id="game" width="960" height="540"></canvas>
        <div id="overlayMessage"></div>

        <div id="upgradePanel">
          <div id="upgradePanelInner">
            <h2>Choose a Power-Up</h2>
            <p>
              Every wave you get a power with a drawback. Max <b>5 normal</b> powers and <b>2 boss/curses</b> – once you’re capped you’ll replace old ones.<br>
              Boss waves offer <b>Legendary</b> options and <b>Curses</b> with extreme tradeoffs.<br>
              Wave challenges can reward you with <b>rerolls</b>.
            </p>
            <div id="upgrades"></div>
            <div style="display:flex;justify-content:space-between;gap:6px;margin-top:4px;">
              <button id="rerollButton">Reroll (0)</button>
              <button id="skipButton">Skip – no power this wave</button>
            </div>
          </div>
        </div>
      </div>

      <div id="hud">
        <div id="hudWave"></div>
        <div id="hudHP"></div>
        <div id="hudStats"></div>
        <div id="hudUlt"></div>
        <div id="hudStyle"></div>
        <div id="hudKills"></div>
        <div id="hudChallenge"></div>
      </div>

      <div id="abilitiesBar">
        <div class="abilitiesGroup">
          <span class="abilitiesTitle">Normal Powers (cap 5):</span>
          <div id="normalAbilitiesList" class="abilitiesList"></div>
        </div>
        <div class="abilitiesGroup">
          <span class="abilitiesTitle">Boss Powers & Curses (cap 2):</span>
          <div id="bossAbilitiesList" class="abilitiesList"></div>
        </div>
      </div>
    </div>

    <div id="statsPanel">
      <h3>Build Stats</h3>
      <div id="statsContent"></div>
    </div>
  </div>

  <!-- MOBILE TOUCH CONTROLS -->
  <div id="mobileControls">
    <div class="mobileGroup">
      <div class="mobileDpad">
        <button class="mobileBtn empty"></button>
        <button class="mobileBtn mobileMove" data-key="w">▲</button>
        <button class="mobileBtn empty"></button>

        <button class="mobileBtn mobileMove" data-key="a">◄</button>
        <button class="mobileBtn empty"></button>
        <button class="mobileBtn mobileMove" data-key="d">►</button>

        <button class="mobileBtn empty"></button>
        <button class="mobileBtn mobileMove" data-key="s">▼</button>
        <button class="mobileBtn empty"></button>
      </div>
    </div>
    <div class="mobileGroup">
      <button class="mobileBtn mobileAction" data-action="shoot">Shoot</button>
      <button class="mobileBtn mobileAction" data-action="dash">Dash</button>
      <button class="mobileBtn mobileAction" data-action="melee">Melee</button>
      <button class="mobileBtn mobileAction" data-action="ult">Ult</button>
    </div>
  </div>

  <script>
    const canvas=document.getElementById("game");
    const ctx=canvas.getContext("2d");
    const overlayMessageEl=document.getElementById("overlayMessage");
    const upgradePanel=document.getElementById("upgradePanel");
    const upgradesContainer=document.getElementById("upgrades");
    const skipButton=document.getElementById("skipButton");
    const rerollButton=document.getElementById("rerollButton");
    const hudWave=document.getElementById("hudWave");
    const hudHP=document.getElementById("hudHP");
    const hudStats=document.getElementById("hudStats");
    const hudUlt=document.getElementById("hudUlt");
    const hudStyle=document.getElementById("hudStyle");
    const hudKills=document.getElementById("hudKills");
    const hudChallenge=document.getElementById("hudChallenge");
    const mainMenu=document.getElementById("mainMenu");
    const normalAbilitiesListEl=document.getElementById("normalAbilitiesList");
    const bossAbilitiesListEl=document.getElementById("bossAbilitiesList");
    const statsContentEl=document.getElementById("statsContent");

    const keys={};
    let mousePos={x:canvas.width/2,y:canvas.height/2};
    let mouseDown=false;

    let combatStyle="ranged";
    let selectedUltId="jjk_domain";
    let selectedArchetype="sorcerer";
    let difficulty="normal";
    let gameState="menu";

    let lastTime=0;
    let messageTimer=0;
    let runTime=0;

    let bgTime=0;
    const particles=[];
    const fireBursts=[];
    const playerBombs=[];
    const slowFields=[];
    let summons=[];
    let bullets=[];
    let enemies=[];
    let enemyBullets=[];
    let enemyIdCounter=1;

    let screenShakeTimer=0;
    let screenShakeDuration=0;
    let screenShakeIntensity=0;
    let whiteFlashAlpha=0;

    const GENJUTSU_DURATION=3.2;
    let bossGenjutsuTimer=0;

    let domainField={
      active:false,
      x:0,y:0,
      radius:220,
      type:null,
      color:"rgba(90,60,200,0.18)",
      edgeColor:"rgba(210,180,255,0.9)"
    };

    let player=null;
    let wave=0;
    let runKills=0;

    let normalAbilities=[];
    let bossAbilities=[];
    let curses=[];
    let activeCurses=[];

    let noLimitMode=false;
    let replaceTarget=null;

    let enemyScale={
      hpMult:1,
      speedMult:1,
      damageMult:1,
      countMult:1,
      bulletSpeedMult:1,
      bulletDamageMult:1
    };

    let nextWavePending=false;
    let nextWaveDelay=0;

    // Wave challenges
    let playerRerolls=0;
    let currentChallenge=null; // {type, active, failed, description, kills, targetKills, timer}

    const DIFFICULTY_SETTINGS={
      chill:{enemyHpMult:0.85,enemyDamageMult:0.7,enemyCountMult:0.9},
      normal:{enemyHpMult:1,enemyDamageMult:0.9,enemyCountMult:1},
      cursed:{enemyHpMult:1.2,enemyDamageMult:1.1,enemyCountMult:1.15}
    };

    const BOSS_TEMPLATES=[
      {id:"mahito",name:"Mahito",color:"#b88cff"},
      {id:"itachi",name:"Itachi",color:"#ff6666"},
      {id:"gojo",name:"Gojo",color:"#7bd0ff"},
      {id:"luffy",name:"Gear Fifth Luffy",color:"#ffd480"}
    ];

    const MINI_BOSS_TEMPLATES=[
      {id:"upper_moon_demon",name:"Upper Moon Demon",color:"#ff9966",pattern:"cone"},
      {id:"high_end_nomu",name:"High-End Nomu",color:"#c84cff",pattern:"rush"},
      {id:"armored_titan",name:"Armored Titan",color:"#d8aa6a",pattern:"spin"}
    ];

    const ARCHETYPES={
      swordsman:{id:"swordsman",name:"Sharp Swordsman",startAbilities:["water_breathing","blood_edge"]},
      sorcerer:{id:"sorcerer",name:"Cursed Sorcerer",startAbilities:["shadow_garden","black_flash_rhythm"]},
      titan:{id:"titan",name:"Titan Slayer",startAbilities:["survey_maneuvers","shadow_army_commander"]},
      hero:{id:"hero",name:"Quirked Hero",startAbilities:["fire_force_spark","heroic_guard"]},
    };

    const COSMETICS={
      skins:[
        {id:"skin_default",name:"Default Hunter",unlockCheck:(s)=>true},
        {id:"skin_hashira",name:"Hashira Cloak",unlockCheck:(s)=>s.maxWaveEver>=10},
        {id:"skin_domain_freak",name:"Domain Freak",unlockCheck:(s)=>s.totalDomainsCast>=3},
        {id:"skin_shadow_monarch",name:"Shadow Monarch",unlockCheck:(s)=>s.defeatedBossWithShadowCommanderOnce},
        {id:"skin_flame_hashira",name:"Flame Hashira",unlockCheck:(s)=>s.bossesKilled>=5},
        {id:"skin_sukuna_king",name:"King of Curses",unlockCheck:(s)=>s.cursesTaken>=3},
        {id:"skin_apex_legend",name:"Apex Operator",unlockCheck:(s)=>s.maxWaveEver>=20}
      ],
      bulletTrails:[
        {id:"trail_default",name:"Default Trail",unlockCheck:(s)=>true},
        {id:"trail_flame",name:"Flame Rounds",unlockCheck:(s)=>s.bossesKilled>=1},
        {id:"trail_cursed",name:"Cursed Sparks",unlockCheck:(s)=>s.cursesTaken>=1},
        {id:"trail_lightning",name:"Lightning Shots",unlockCheck:(s)=>s.reachedStyleSOnce},
        {id:"trail_blood",name:"Blood Rounds",unlockCheck:(s)=>s.cursesTaken>=2},
        {id:"trail_void",name:"Void Rounds",unlockCheck:(s)=>s.bossesKilled>=5}
      ],
      dashTrails:[
        {id:"dash_default",name:"Default Dash",unlockCheck:(s)=>true},
        {id:"dash_afterimage",name:"Afterimage Step",unlockCheck:(s)=>s.totalDashes>=50},
        {id:"dash_void",name:"Void Step",unlockCheck:(s)=>s.maxWaveEver>=15},
        {id:"dash_flame",name:"Flame Dash",unlockCheck:(s)=>s.bossesKilled>=2},
        {id:"dash_cursed",name:"Cursed Dash",unlockCheck:(s)=>s.cursesTaken>=2}
      ]
    };

    const ACHIEVEMENTS=[
      {
        id:"wave5",
        name:"First Trial",
        desc:"Reach Wave 5 in any mode.",
        check:(s)=>s.maxWaveEver>=5,
        progress:(s)=>`${Math.min(s.maxWaveEver,5)}/5 waves`
      },
      {
        id:"wave10",
        name:"Hashira Prospects",
        desc:"Reach Wave 10 (unlocks Hashira Cloak).",
        check:(s)=>s.maxWaveEver>=10,
        progress:(s)=>`${Math.min(s.maxWaveEver,10)}/10 waves`
      },
      {
        id:"domain_addict",
        name:"Domain Addict",
        desc:"Cast a domain-style ultimate 3 times.",
        check:(s)=>s.totalDomainsCast>=3,
        progress:(s)=>`${Math.min(s.totalDomainsCast,3)}/3 casts`
      },
      {
        id:"boss_slayer",
        name:"Boss Slayer",
        desc:"Defeat 3 bosses total.",
        check:(s)=>s.bossesKilled>=3,
        progress:(s)=>`${Math.min(s.bossesKilled,3)}/3 bosses`
      },
      {
        id:"cursed_runner",
        name:"Cursed Runner",
        desc:"Take at least 1 Curse in a run.",
        check:(s)=>s.cursesTaken>=1,
        progress:(s)=>`${Math.min(s.cursesTaken,1)}/1 curse`
      },
      {
        id:"style_god",
        name:"Style God",
        desc:"Reach Style rank S at least once.",
        check:(s)=>s.reachedStyleSOnce,
        progress:(s)=>s.reachedStyleSOnce?"Done":"Not yet"
      },
      {
        id:"shadow_general",
        name:"Shadow General",
        desc:"Defeat a boss while using Shadow Army Commander.",
        check:(s)=>s.defeatedBossWithShadowCommanderOnce,
        progress:(s)=>s.defeatedBossWithShadowCommanderOnce?"Done":"Not yet"
      },
      {
        id:"cursed_builder",
        name:"Cursed Builder",
        desc:"Take at least 2 curses across your runs.",
        check:(s)=>s.cursesTaken>=2,
        progress:(s)=>`${Math.min(s.cursesTaken,2)}/2 curses`
      },
      {
        id:"challenge_runner",
        name:"Challenge Runner",
        desc:"Complete 3 wave challenges.",
        check:(s)=>s.challengesCompleted>=3,
        progress:(s)=>`${Math.min(s.challengesCompleted,3)}/3 challenges`
      },
      {
        id:"melee_fiend",
        name:"Melee Fiend",
        desc:"Land 60 melee hits.",
        check:(s)=>s.meleeHits>=60,
        progress:(s)=>`${Math.min(s.meleeHits,60)}/60 hits`
      }
    ];

    let cosmeticUnlocks={};
    let cosmeticSelection={
      skin:"skin_default",
      bulletTrail:"trail_default",
      dashTrail:"dash_default"
    };
    let cosmeticStats={
      maxWaveEver:0,
      totalDashes:0,
      totalDomainsCast:0,
      bossesKilled:0,
      cursesTaken:0,
      reachedStyleSOnce:false,
      defeatedBossWithShadowCommanderOnce:false,
      challengesCompleted:0,
      rerollsEarned:0,
      meleeHits:0,
      bulletShots:0
    };

    let gameSettings={
      screenShake:true,
      lowFlash:false,
      showHints:true
    };

    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const distance=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
    function shuffled(a){a=a.slice();for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
    function angleDiff(a,b){let d=a-b;while(d>Math.PI)d-=Math.PI*2;while(d<-Math.PI)d+=Math.PI*2;return d;}

    function showMessage(msg,t=2){
      if(!gameSettings.showHints)return;
      overlayMessageEl.textContent=msg;
      messageTimer=t;
    }
    function addScreenShake(intensity,duration){
      if(!gameSettings.screenShake)return;
      screenShakeIntensity=Math.max(screenShakeIntensity,intensity);
      screenShakeDuration=Math.max(screenShakeDuration,duration);
      screenShakeTimer=Math.max(screenShakeTimer,duration);
    }
    function addWhiteFlash(strength){
      const limit=gameSettings.lowFlash?0.35:1;
      const scale=gameSettings.lowFlash?0.6:1;
      whiteFlashAlpha=Math.min(limit,whiteFlashAlpha+strength*scale);
    }

    /* INPUT */

    window.addEventListener("keydown",e=>{
      const k=e.key.toLowerCase();
      keys[k]=true;
      if(e.code==="Space"&&gameState==="playing")startDash();
      if(e.code==="KeyE"&&gameState==="playing")tryMeleeAttack();
      if(k==="q"&&gameState==="playing")tryUseUlt();
      if(k==="r"&&gameState==="gameover")resetGame();
    });
    window.addEventListener("keyup",e=>{
      keys[e.key.toLowerCase()]=false;
    });

    canvas.addEventListener("mousemove",e=>{
      const r=canvas.getBoundingClientRect();
      mousePos.x=e.clientX-r.left;
      mousePos.y=e.clientY-r.top;
    });
    canvas.addEventListener("mousedown",e=>{
      if(e.button===0)mouseDown=true;
      if(e.button===2&&gameState==="playing")tryMeleeAttack();
    });
    canvas.addEventListener("mouseup",e=>{
      if(e.button===0)mouseDown=false;
    });
    canvas.addEventListener("contextmenu",e=>e.preventDefault());

    function initMobileControls(){
      const mc=document.getElementById("mobileControls");
      const isTouch=("ontouchstart" in window)||(navigator.maxTouchPoints>0);
      if(!mc||!isTouch)return;
      mc.style.display="flex";

      function bindMove(btn,key){
        const start=(ev)=>{keys[key]=true;ev.preventDefault();};
        const end=(ev)=>{keys[key]=false;ev.preventDefault();};
        btn.addEventListener("touchstart",start,{passive:false});
        btn.addEventListener("touchend",end,{passive:false});
        btn.addEventListener("touchcancel",end,{passive:false});
      }
      document.querySelectorAll(".mobileMove").forEach(btn=>{
        const key=btn.getAttribute("data-key");
        bindMove(btn,key);
      });

      function bindAction(btn,action){
        const start=(ev)=>{
          if(action==="shoot")mouseDown=true;
          else if(action==="dash")startDash();
          else if(action==="melee")tryMeleeAttack();
          else if(action==="ult")tryUseUlt();
          ev.preventDefault();
        };
        const end=(ev)=>{
          if(action==="shoot")mouseDown=false;
          ev.preventDefault();
        };
        btn.addEventListener("touchstart",start,{passive:false});
        btn.addEventListener("touchend",end,{passive:false});
        btn.addEventListener("touchcancel",end,{passive:false});
      }
      document.querySelectorAll(".mobileAction").forEach(btn=>{
        const action=btn.getAttribute("data-action");
        bindAction(btn,action);
      });

      canvas.addEventListener("touchstart",e=>{
        const t=e.touches[0];
        if(!t)return;
        const r=canvas.getBoundingClientRect();
        mousePos.x=t.clientX-r.left;
        mousePos.y=t.clientY-r.top;
        mouseDown=true;
        e.preventDefault();
      },{passive:false});
      canvas.addEventListener("touchmove",e=>{
        const t=e.touches[0];
        if(!t)return;
        const r=canvas.getBoundingClientRect();
        mousePos.x=t.clientX-r.left;
        mousePos.y=t.clientY-r.top;
        e.preventDefault();
      },{passive:false});
      canvas.addEventListener("touchend",e=>{
        mouseDown=false;
        e.preventDefault();
      },{passive:false});
      canvas.addEventListener("touchcancel",e=>{
        mouseDown=false;
        e.preventDefault();
      },{passive:false});
    }

    /* SETTINGS + COSMETICS PERSIST */

    function loadSettings(){
      try{
        const raw=localStorage.getItem("animeRogue_settings");
        if(raw){
          const s=JSON.parse(raw);
          gameSettings={...gameSettings,...s};
        }
      }catch(e){}
    }
    function saveSettings(){
      try{
        localStorage.setItem("animeRogue_settings",JSON.stringify(gameSettings));
      }catch(e){}
    }

    function ensureBaseCosmeticsUnlocked(){
      ["skin_default","trail_default","dash_default"].forEach(id=>{cosmeticUnlocks[id]=true;});
    }
    function loadCosmeticsFromStorage(){
      try{
        const u=localStorage.getItem("animeRogue_cosmeticUnlocks");
        if(u)cosmeticUnlocks=JSON.parse(u)||{};
        const s=localStorage.getItem("animeRogue_cosmeticStats");
        if(s)cosmeticStats={...cosmeticStats,...JSON.parse(s)};
        const sel=localStorage.getItem("animeRogue_cosmeticSelection");
        if(sel)cosmeticSelection={...cosmeticSelection,...JSON.parse(sel)};
      }catch(e){cosmeticUnlocks={};}
      ensureBaseCosmeticsUnlocked();
    }
    function saveCosmeticUnlocks(){try{localStorage.setItem("animeRogue_cosmeticUnlocks",JSON.stringify(cosmeticUnlocks));}catch(e){}}
    function saveCosmeticStats(){try{localStorage.setItem("animeRogue_cosmeticStats",JSON.stringify(cosmeticStats));}catch(e){}}
    function saveCosmeticSelection(){try{localStorage.setItem("animeRogue_cosmeticSelection",JSON.stringify(cosmeticSelection));}catch(e){}}

    function refreshAchievementsUI(){
      const container=document.getElementById("achievementsList");
      if(!container)return;
      const s=cosmeticStats;
      let html="";
      ACHIEVEMENTS.forEach(a=>{
        const unlocked=a.check(s);
        const prog=a.progress?a.progress(s):(unlocked?"Done":"");
        html+=`
          <div class="achievementItem ${unlocked?"achieved":""}">
            <div class="achievementName">${a.name}</div>
            <div class="achievementDesc">${a.desc}</div>
            <div class="achievementProgress">${prog}</div>
          </div>
        `;
      });
      container.innerHTML=html;
    }

    function checkCosmeticUnlocks(){
      ensureBaseCosmeticsUnlocked();
      const s=cosmeticStats;
      const checkGroup=(list)=>{
        for(const c of list){
          if(cosmeticUnlocks[c.id])continue;
          let unlocked=false;
          if(!c.unlockCheck)unlocked=true;
          else unlocked=!!c.unlockCheck(s);
          if(unlocked)cosmeticUnlocks[c.id]=true;
        }
      };
      checkGroup(COSMETICS.skins);
      checkGroup(COSMETICS.bulletTrails);
      checkGroup(COSMETICS.dashTrails);
      saveCosmeticUnlocks();
      refreshCosmeticButtons();
      refreshAchievementsUI();
    }

    function refreshCosmeticButtons(){
      const skinButtons=document.querySelectorAll(".skinButton");
      skinButtons.forEach(btn=>{
        const id=btn.getAttribute("data-skin");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="skin_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.skin===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
      const trailButtons=document.querySelectorAll(".trailButton");
      trailButtons.forEach(btn=>{
        const id=btn.getAttribute("data-trail");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="trail_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.bulletTrail===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
      const dashButtons=document.querySelectorAll(".dashButton");
      dashButtons.forEach(btn=>{
        const id=btn.getAttribute("data-dash");
        const unlocked=!!cosmeticUnlocks[id];
        btn.classList.remove("cosmeticLocked","styleActive","cosmeticSelected");
        if(!unlocked && id!=="dash_default")btn.classList.add("cosmeticLocked");
        if(cosmeticSelection.dashTrail===id && unlocked)btn.classList.add("styleActive","cosmeticSelected");
      });
    }

    function initCosmeticsSystem(){
      loadCosmeticsFromStorage();
      checkCosmeticUnlocks();
      document.querySelectorAll(".skinButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-skin");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Skin locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.skin=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
      document.querySelectorAll(".trailButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-trail");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Bullet trail locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.bulletTrail=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
      document.querySelectorAll(".dashButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          const id=btn.getAttribute("data-dash");
          const unlocked=!!cosmeticUnlocks[id];
          if(!unlocked){showMessage("Dash trail locked – keep playing to unlock it!",2.2);return;}
          cosmeticSelection.dashTrail=id;
          saveCosmeticSelection();
          refreshCosmeticButtons();
        });
      });
    }

    function setupSettingsUI(){
      const cbShake=document.getElementById("settingScreenShake");
      const cbLowFlash=document.getElementById("settingLowFlash");
      const cbHints=document.getElementById("settingShowHints");
      if(cbShake)cbShake.checked=!!gameSettings.screenShake;
      if(cbLowFlash)cbLowFlash.checked=!!gameSettings.lowFlash;
      if(cbHints)cbHints.checked=!!gameSettings.showHints;

      if(cbShake){
        cbShake.addEventListener("change",()=>{
          gameSettings.screenShake=cbShake.checked;
          saveSettings();
        });
      }
      if(cbLowFlash){
        cbLowFlash.addEventListener("change",()=>{
          gameSettings.lowFlash=cbLowFlash.checked;
          saveSettings();
        });
      }
      if(cbHints){
        cbHints.addEventListener("change",()=>{
          gameSettings.showHints=cbHints.checked;
          if(!gameSettings.showHints){
            overlayMessageEl.textContent="";
            messageTimer=0;
          }
          saveSettings();
        });
      }
    }

    function getPlayerSkinTheme(){
      switch(cosmeticSelection.skin){
        case "skin_hashira":
          return{bodyColor:"#1c2733",outlineColor:"#7cf0c1",auraColor:"rgba(124,240,193,0.45)",dashGlowColor:"#7cf0c1",weaponColor:"#c8fff3"};
        case "skin_domain_freak":
          return{bodyColor:"#33204f",outlineColor:"#d2b3ff",auraColor:"rgba(164,118,255,0.5)",dashGlowColor:"#e6d2ff",weaponColor:"#f5e6ff"};
        case "skin_shadow_monarch":
          return{bodyColor:"#101018",outlineColor:"#b68bff",auraColor:"rgba(94,70,140,0.65)",dashGlowColor:"#b68bff",weaponColor:"#f0e6ff"};
        case "skin_flame_hashira":
          return{bodyColor:"#3a1a12",outlineColor:"#ffcf8a",auraColor:"rgba(255,160,90,0.55)",dashGlowColor:"#ffcf8a",weaponColor:"#ffe9c0"};
        case "skin_sukuna_king":
          return{bodyColor:"#281018",outlineColor:"#ff96b5",auraColor:"rgba(255,140,170,0.6)",dashGlowColor:"#ff96b5",weaponColor:"#ffe6f0"};
        case "skin_apex_legend":
          return{bodyColor:"#24313d",outlineColor:"#86e1ff",auraColor:"rgba(110,210,255,0.5)",dashGlowColor:"#86e1ff",weaponColor:"#f6feff"};
        default:
          return{bodyColor:"#39c5ff",outlineColor:"#9ff6ff",auraColor:"rgba(120,200,255,0.55)",dashGlowColor:"#9ff6ff",weaponColor:"#ffffff"};
      }
    }
    function getBulletColor(){
      switch(cosmeticSelection.bulletTrail){
        case "trail_flame":return"#ffb35c";
        case "trail_cursed":return"#c68cff";
        case "trail_lightning":return"#e7f6ff";
        case "trail_blood":return"#ff6b6b";
        case "trail_void":return"#c3b6ff";
        default:return"#f5f5f5";
      }
    }
    function getBulletTrailParticleColor(){
      switch(cosmeticSelection.bulletTrail){
        case "trail_flame":return"rgba(255,180,120,1)";
        case "trail_cursed":return"rgba(200,140,255,1)";
        case "trail_lightning":return"rgba(230,250,255,1)";
        case "trail_blood":return"rgba(255,120,120,1)";
        case "trail_void":return"rgba(210,190,255,1)";
        default:return null;
      }
    }
    function getDashParticleColor(){
      switch(cosmeticSelection.dashTrail){
        case "dash_afterimage":return"rgba(255,255,255,0.9)";
        case "dash_void":return"rgba(110,90,180,1)";
        case "dash_flame":return"rgba(255,160,90,1)";
        case "dash_cursed":return"rgba(220,120,255,1)";
        default:return"rgba(160,220,255,1)";
      }
    }
    function addBulletTrailFX(b){
      const color=getBulletTrailParticleColor();
      if(!color)return;
      if(Math.random()>0.5)return;
      spawnParticles(b.x,b.y,{
        count:1,speedMin:10,speedMax:40,lifeMin:0.2,lifeMax:0.5,sizeMin:1.2,sizeMax:2.4,color
      });
    }

    /* BACKGROUND */

    function updateBackground(dt){bgTime+=dt;}
    function drawBackground(){
      const cx=canvas.width/2;
      const cy=canvas.height/2;

      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,canvas.width*0.9);
      g.addColorStop(0,"#14172a");
      g.addColorStop(0.4,"#090918");
      g.addColorStop(1,"#020208");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      const gridSize=32;
      const scroll=(bgTime*25)%gridSize;

      ctx.save();
      ctx.translate(0,canvas.height*0.15);
      ctx.globalAlpha=0.3;
      ctx.strokeStyle="#283757";
      ctx.lineWidth=1;
      for(let x=-gridSize;x<canvas.width+gridSize;x+=gridSize){
        ctx.beginPath();
        ctx.moveTo(Math.floor(x+scroll)+0.5,0);
        ctx.lineTo(Math.floor(x+scroll)+0.5,canvas.height);
        ctx.stroke();
      }
      for(let y=0;y<canvas.height;y+=gridSize){
        const yy=Math.floor(y+scroll)+0.5;
        ctx.beginPath();
        ctx.moveTo(0,yy);
        ctx.lineTo(canvas.width,yy);
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.globalAlpha=0.12;
      ctx.strokeStyle="#7e5bff";
      ctx.lineWidth=2;
      const t=bgTime*40;
      for(let i=0;i<4;i++){
        const offset=(t+i*120)%(canvas.width+200)-100;
        ctx.beginPath();
        ctx.moveTo(offset,-20);
        ctx.lineTo(offset+160,canvas.height+40);
        ctx.stroke();
      }
      ctx.restore();

      const cell=8;
      ctx.save();
      ctx.globalAlpha=0.04;
      for(let y=0;y<canvas.height;y+=cell){
        for(let x=0;x<canvas.width;x+=cell){
          if(((x+y)>>3)&1){
            ctx.fillStyle="#000000";
            ctx.fillRect(x,y,cell,cell);
          }
        }
      }
      ctx.restore();

      const vg=ctx.createRadialGradient(cx,cy,canvas.width*0.35,cx,cy,canvas.width*0.95);
      vg.addColorStop(0,"rgba(0,0,0,0)");
      vg.addColorStop(1,"rgba(0,0,0,0.8)");
      ctx.fillStyle=vg;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    /* PARTICLES */

    function spawnParticles(x,y,opt={}){
      const{
        count=12,spread=Math.PI*2,
        speedMin:spMin=80,speedMax:spMax=260,
        lifeMin=0.25,lifeMax=0.6,
        sizeMin=2,sizeMax=4,
        color="rgba(255,255,255,1)"
      }=opt;
      for(let i=0;i<count;i++){
        const ang=Math.random()*spread;
        const s=spMin+Math.random()*(spMax-spMin);
        const vx=Math.cos(ang)*s;
        const vy=Math.sin(ang)*s;
        const life=lifeMin+Math.random()*(lifeMax-lifeMin);
        const size=sizeMin+Math.random()*(sizeMax-sizeMin);
        particles.push({x,y,vx,vy,life,maxLife:life,size,color,renderColor:color});
      }
    }
    function updateParticles(dt){
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];
        p.life-=dt;
        if(p.life<=0){particles.splice(i,1);continue;}
        const t=p.life/p.maxLife;
        p.x+=p.vx*dt;
        p.y+=p.vy*dt;
        p.vx*=0.97;
        p.vy+=20*dt;
        const m=p.color.match(/rgba\((\d+),(\d+),(\d+),([\d.]+)\)/);
        if(m){
          const[r,g,b]=[m[1],m[2],m[3]];
          p.renderColor=`rgba(${r},${g},${b},${t})`;
        }else p.renderColor=p.color;
      }
    }
    function drawParticles(){
      for(const p of particles){
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
        ctx.fillStyle=p.renderColor||p.color;
        ctx.fill();
      }
    }

    /* PLAYER / STATS BASE */

    const BASE_STATS={
      maxHp:110,
      damage:16,
      fireRate:3,
      speed:230,
      bulletSpeed:550,
      bulletsPerShot:1,
      spread:0.18,
      pierce:0,
      onHitHeal:0,
      healAfterWave:12,
      dashCooldown:1.1,
      dashDuration:0.22,
      meleeDamage:42,
      meleeRange:95,
      meleeArc:1.7,
      meleeCooldown:0.6,
      meleeOnHitHeal:1
    };

    function createPlayer(){
      return{
        x:canvas.width/2,y:canvas.height/2,radius:10,
        hp:BASE_STATS.maxHp,maxHp:BASE_STATS.maxHp,
        damage:BASE_STATS.damage,
        fireRate:BASE_STATS.fireRate,
        speed:BASE_STATS.speed,
        bulletSpeed:BASE_STATS.bulletSpeed,
        bulletsPerShot:BASE_STATS.bulletsPerShot,
        spread:BASE_STATS.spread,
        pierce:0,
        onHitHeal:BASE_STATS.onHitHeal,
        healAfterWave:BASE_STATS.healAfterWave,
        shootTimer:0,
        dashCooldown:BASE_STATS.dashCooldown,
        dashDuration:BASE_STATS.dashDuration,
        dashCooldownTimer:0,
        dashActiveTimer:0,
        isDashing:false,
        dashVelX:0,dashVelY:0,
        dashMode:"normal",
        meleeDamage:BASE_STATS.meleeDamage,
        meleeRange:BASE_STATS.meleeRange,
        meleeArc:BASE_STATS.meleeArc,
        meleeCooldown:BASE_STATS.meleeCooldown,
        meleeCooldownTimer:0,
        meleeSwingTimer:0,
        meleeSwingDuration:0.18,
        meleeAngle:0,
        meleeOnHitHeal:BASE_STATS.meleeOnHitHeal,
        incomingDamageMult:1,
        onHitHealMult:1,
        healAfterWaveMult:1,
        styleMeter:0,
        styleMax:100,
        styleDecayRate:6,
        styleGainMult:1,
        ultId:null,
        ultCooldownTimer:0,
        ultActiveTimer:0,
        ultDamageMult:1,
        ultFireRateMult:1,
        ultSpeedMult:1,
        ultMeleeDamageMult:1,
        ultMeleeRangeMult:1,
        ultPierceBonus:0,
        ultMeleeHealBonus:0,
        ultBulletSpeedMult:1,
        ultIncomingDamageMult:1,
        ultCharge:0,
        ultChargeGainMult:1,
        ultDurationMult:1,
        ultReady:false,
        lastStandActive:false,
        mahitoTouchStacks:0,
        summonDpsMult:1,
        bossDamageMult:1,
        damageVsHighHpMult:1,
        damageVsLowHpMult:1,
        normalAbilities:[],
        bossAbilities:[]
      };
    }

    const NORMAL_POWER_CAP=5;
    const BOSS_POWER_CAP=2;

    function playerHasAbility(id){
      if(!player)return false;
      return (player.normalAbilities && player.normalAbilities.includes(id)) ||
             (player.bossAbilities && player.bossAbilities.includes(id)) ||
             activeCurses.includes(id);
    }

    function getAbilityById(id){
      return normalAbilities.find(a=>a.id===id)||bossAbilities.find(a=>a.id===id)||null;
    }
    function getCurseById(id){
      return curses.find(c=>c.id===id)||null;
    }
    function hasCurse(id){return activeCurses.includes(id);}

    let summonsSummonCount=0;
    /* ABILITY DEFINITIONS */

    const NORMAL_ABILITY_DEFS=[
      /* ===== GENERIC COMMONS ===== */
      {
        id:"swift_feet",
        name:"Swift Feet",
        rarity:"common",
        type:"normal",
        description:"+15% move speed, -8% max HP.",
        requires:null,
        statMods:{speedMult:1.15,maxHpMult:0.92}
      },
      {
        id:"steady_guard",
        name:"Steady Guard",
        rarity:"common",
        type:"normal",
        description:"+20% max HP, -12% move speed.",
        requires:null,
        statMods:{maxHpMult:1.20,speedMult:0.88}
      },
      {
        id:"focused_shot",
        name:"Focused Shot",
        rarity:"common",
        type:"normal",
        description:"+18% damage, -15% fire rate.",
        requires:null,
        statMods:{damageMult:1.18,fireRateMult:0.85}
      },
      {
        id:"jitter_fire",
        name:"Jitter Fire",
        rarity:"common",
        type:"normal",
        description:"+22% fire rate, +20% spread.",
        requires:null,
        statMods:{fireRateMult:1.22,spreadMult:1.2}
      },
      {
        id:"iron_body",
        name:"Iron Body",
        rarity:"common",
        type:"normal",
        description:"-10% damage taken, -10% damage dealt.",
        requires:null,
        statMods:{incomingDamageMult:0.9,damageMult:0.9}
      },
      {
        id:"clean_footwork",
        name:"Clean Footwork",
        rarity:"common",
        type:"normal",
        description:"+15% dash distance, +10% dash cooldown, -10% melee damage.",
        requires:null,
        statMods:{dashDistanceMult:1.15,dashCooldownMult:1.1,meleeDamageMult:0.9}
      },
      {
        id:"fragile_power",
        name:"Fragile Power",
        rarity:"common",
        type:"normal",
        description:"+20% damage, +10% damage taken.",
        requires:null,
        statMods:{damageMult:1.2,incomingDamageMult:1.1}
      },
      {
        id:"shielded_core",
        name:"Shielded Core",
        rarity:"common",
        type:"normal",
        description:"Heal after waves +6, -10% fire rate.",
        requires:null,
        statMods:{healAfterWaveMult:1.5,fireRateMult:0.9}
      },

      /* ===== DEMON SLAYER ===== */
      {
        id:"water_breathing",
        name:"Water Breathing",
        rarity:"rare",
        type:"normal",
        description:"+25% melee range, +15% melee damage, -10% bullet damage.",
        requires:null,
        statMods:{meleeRangeMult:1.25,meleeDamageMult:1.15,damageMult:0.9}
      },
      {
        id:"water_breathing_form11",
        name:"Water Breathing: Dead Calm",
        rarity:"epic",
        type:"normal",
        description:"Big melee boost, but halves fire rate.",
        requires:"water_breathing",
        statMods:{meleeRangeMult:1.35,meleeDamageMult:1.35,fireRateMult:0.5}
      },
      {
        id:"flame_style_rengoku",
        name:"Flame Style: Rengoku",
        rarity:"epic",
        type:"normal",
        description:"+35% melee damage and leaves small fire waves, -20% max HP.",
        requires:null,
        statMods:{meleeDamageMult:1.35,maxHpMult:0.8}
      },
      {
        id:"demon_slayer_mark",
        name:"Demon Slayer Mark",
        rarity:"legendary",
        type:"normal",
        description:"+40% melee damage, +20% speed, +25% damage taken.",
        requires:null,
        statMods:{meleeDamageMult:1.4,speedMult:1.2,incomingDamageMult:1.25}
      },

      /* ===== SWORDSMAN EDGE ===== */
      {
        id:"blood_edge",
        name:"Blood Edge",
        rarity:"rare",
        type:"normal",
        description:"Melee hits heal +2 HP, but bullet damage -12%.",
        requires:null,
        statMods:{meleeHealAdd:2,damageMult:0.88}
      },

      /* ===== THUNDER & SPEED ===== */
      {
        id:"thunder_breathing",
        name:"Thunder Breathing",
        rarity:"rare",
        type:"normal",
        description:"+25% dash distance, +20% dash speed, -10% max HP.",
        requires:null,
        statMods:{dashDistanceMult:1.25,dashSpeedMult:1.2,maxHpMult:0.9}
      },
      {
        id:"god_speed_dash",
        name:"God Speed Dash",
        rarity:"epic",
        type:"normal",
        description:"Dashes insanely fast, but dash cooldown doubles.",
        requires:"thunder_breathing",
        statMods:{dashSpeedMult:1.9,dashCooldownMult:2.0}
      },

      /* ===== ONE PIECE ===== */
      {
        id:"gear_second",
        name:"Gear Second",
        rarity:"rare",
        type:"normal",
        description:"+25% fire rate, +10% move speed, +20% damage taken.",
        requires:null,
        statMods:{fireRateMult:1.25,speedMult:1.1,incomingDamageMult:1.2}
      },
      {
        id:"gear_third",
        name:"Gear Third",
        rarity:"epic",
        type:"normal",
        description:"+40% bullet damage, -30% move speed.",
        requires:"gear_second",
        statMods:{damageMult:1.4,speedMult:0.7}
      },
      {
        id:"gear_fourth_snake",
        name:"Gear Fourth: Snake",
        rarity:"legendary",
        type:"normal",
        description:"+30% damage and bullets slightly home, -20% fire rate.",
        requires:"gear_third",
        statMods:{damageMult:1.3,fireRateMult:0.8}
      },

      /* ===== JJK – TOJI / NANAMI / SHADOWS ===== */
      {
        id:"cursed_family",
        name:"Cursed Family",
        rarity:"rare",
        type:"normal",
        description:"Inverted Spear of Heaven: +30% melee damage, +15% melee range, -15% max HP.",
        requires:null,
        statMods:{meleeDamageMult:1.3,meleeRangeMult:1.15,maxHpMult:0.85}
      },
      {
        id:"ratio_strike",
        name:"Ratio Strike",
        rarity:"epic",
        type:"normal",
        description:"Nanami weak points: +35% damage to high HP enemies, -15% to low HP ones.",
        requires:null,
        statMods:{damageVsHighHpMult:1.35,damageVsLowHpMult:0.85}
      },
      {
        id:"black_flash_rhythm",
        name:"Black Flash Rhythm",
        rarity:"epic",
        type:"normal",
        description:"+30% damage after dashing, but base fire rate -20%.",
        requires:null,
        statMods:{styleGainMult:1.4,fireRateMult:0.8}
      },
      {
        id:"shadow_garden",
        name:"Shadow Garden (Passive)",
        rarity:"rare",
        type:"normal",
        description:"Summons deal +25% damage, heal after wave -20%.",
        requires:null,
        statMods:{summonPowerMult:1.25,healAfterWaveMult:0.8}
      },
      {
        id:"shadow_soldier",
        name:"Shadow Soldier",
        rarity:"rare",
        type:"normal",
        description:"Summon a small shadow ally that attacks. -10% your bullet damage.",
        requires:null,
        statMods:{summonCountAdd:1,summonPowerMult:1.0,damageMult:0.9}
      },
      {
        id:"shadow_army_commander",
        name:"Shadow Army Commander",
        rarity:"epic",
        type:"normal",
        description:"Summon 3 strong shadows, -20% fire rate, -10% move speed.",
        requires:"shadow_soldier",
        statMods:{summonCountAdd:3,summonPowerMult:1.25,fireRateMult:0.8,speedMult:0.9}
      },
      {
        id:"monarchs_authority",
        name:"Monarch's Authority",
        rarity:"legendary",
        type:"normal",
        description:"Summons gain +60% damage, enemies gain +15% HP.",
        requires:"shadow_army_commander",
        statMods:{summonPowerMult:1.6,enemyHpMult:1.15}
      },

      /* ===== DRAGON BALL ===== */
      {
        id:"kaioken",
        name:"Kaioken",
        rarity:"epic",
        type:"normal",
        description:"+30% damage & speed, +25% damage taken.",
        requires:null,
        statMods:{damageMult:1.3,speedMult:1.3,incomingDamageMult:1.25}
      },
      {
        id:"super_saiyan_focus",
        name:"Super Saiyan Focus",
        rarity:"legendary",
        type:"normal",
        description:"+25% damage, +25% fire rate, -20% heal after wave.",
        requires:null,
        statMods:{damageMult:1.25,fireRateMult:1.25,healAfterWaveMult:0.8}
      },

      /* ===== BLEACH ===== */
      {
        id:"shikai_edge",
        name:"Shikai Edge",
        rarity:"rare",
        type:"normal",
        description:"+25% melee damage, -15% bullet damage.",
        requires:null,
        statMods:{meleeDamageMult:1.25,damageMult:0.85}
      },
      {
        id:"bankai_unleashed",
        name:"Bankai Unleashed",
        rarity:"legendary",
        type:"normal",
        description:"+40% melee & bullet damage, +15% damage taken.",
        requires:"shikai_edge",
        statMods:{damageMult:1.4,meleeDamageMult:1.4,incomingDamageMult:1.15}
      },

      /* ===== MHA / FIRE FORCE ===== */
      {
        id:"full_cowl",
        name:"Full Cowl",
        rarity:"rare",
        type:"normal",
        description:"+20% move speed, +15% dash distance, -10% damage.",
        requires:null,
        statMods:{speedMult:1.2,dashDistanceMult:1.15,damageMult:0.9}
      },
      {
        id:"smokescreen_feint",
        name:"Smokescreen Feint",
        rarity:"rare",
        type:"normal",
        description:"Dashing leaves a small slow field, dash cooldown +15%.",
        requires:null,
        statMods:{dashCooldownMult:1.15}
      },
      {
        id:"fire_force_spark",
        name:"Fire Force Spark",
        rarity:"rare",
        type:"normal",
        description:"+15% fire rate & ignite, -10% max HP.",
        requires:null,
        statMods:{fireRateMult:1.15,maxHpMult:0.9}
      },
      {
        id:"ignition_boost",
        name:"Ignition Boost",
        rarity:"epic",
        type:"normal",
        description:"+25% damage, +15% move speed, +15% damage taken.",
        requires:"fire_force_spark",
        statMods:{damageMult:1.25,speedMult:1.15,incomingDamageMult:1.15}
      },

      /* ===== ATTACK ON TITAN ===== */
      {
        id:"survey_maneuvers",
        name:"Survey Maneuvers",
        rarity:"rare",
        type:"normal",
        description:"+20% move speed & dash distance, -10% heal after wave.",
        requires:null,
        statMods:{speedMult:1.2,dashDistanceMult:1.2,healAfterWaveMult:0.9}
      },
      {
        id:"titan_slayer_focus",
        name:"Titan Slayer Focus",
        rarity:"epic",
        type:"normal",
        description:"+35% damage vs bosses, -10% damage vs others.",
        requires:null,
        statMods:{bossDamageMult:1.35,damageMult:0.9}
      },

      /* ===== DEVIL MAY CRY / APEX MOVEMENT ===== */
      {
        id:"trickster_dash",
        name:"Trickster Dash",
        rarity:"rare",
        type:"normal",
        description:"Dash distance +20%, dash cooldown -15%, -10% max HP.",
        requires:null,
        statMods:{dashDistanceMult:1.2,dashCooldownMult:0.85,maxHpMult:0.9}
      },
      {
        id:"royalguard_parry",
        name:"Royalguard Parry",
        rarity:"epic",
        type:"normal",
        description:"While dashing you take 50% less damage, but dash cooldown +20%.",
        requires:null,
        statMods:{dashCooldownMult:1.2,incomingDamageMult:0.95}
      },
      {
        id:"apex_slide",
        name:"Apex Slide",
        rarity:"rare",
        type:"normal",
        description:"+15% move speed and dash distance, -15% melee damage.",
        requires:null,
        statMods:{speedMult:1.15,dashDistanceMult:1.15,meleeDamageMult:0.85}
      },
      {
        id:"tactical_grenade",
        name:"Tactical Grenade",
        rarity:"epic",
        type:"normal",
        description:"Bullets have a small explosion on hit, fire rate -15%.",
        requires:null,
        statMods:{fireRateMult:0.85}
      },

      /* ===== GHOUL / CYBERPUNK ===== */
      {
        id:"ghoul_frenzy",
        name:"Ghoul Frenzy",
        rarity:"epic",
        type:"normal",
        description:"Hits heal +3 HP, but +20% damage taken.",
        requires:null,
        statMods:{onHitHealAdd:3,incomingDamageMult:1.2}
      },
      {
        id:"sandevistan_reflex",
        name:"Sandevistan Reflex",
        rarity:"epic",
        type:"normal",
        description:"+40% move & dash speed during ult, ult charges 20% slower.",
        requires:null,
        statMods:{ultChargeGainMult:0.8,ultSpeedBoostMult:1.4}
      },

      /* ===== DASH REPLACERS ===== */
      {
        id:"flame_dash",
        name:"Flame Dash",
        rarity:"rare",
        type:"normal",
        description:"Dash leaves a line of fire, dash cooldown +20%.",
        requires:null,
        dashMode:"flame",
        statMods:{dashCooldownMult:1.2}
      },
      {
        id:"bomb_dash",
        name:"Bomb Dash",
        rarity:"epic",
        type:"normal",
        description:"Dash drops a timed bomb. Dash shorter and cooldown longer.",
        requires:null,
        dashMode:"bomb",
        statMods:{dashCooldownMult:1.3,dashDurationMult:0.85}
      },

      /* ===== SUPPORT / DEFENCE ===== */
      {
        id:"heroic_guard",
        name:"Heroic Guard",
        rarity:"rare",
        type:"normal",
        description:"-15% damage taken, -10% damage.",
        requires:null,
        statMods:{incomingDamageMult:0.85,damageMult:0.9}
      },
      {
        id:"limiter_chain",
        name:"Limiter Chain",
        rarity:"epic",
        type:"normal",
        description:"-25% damage taken, -20% fire rate and -10% move speed.",
        requires:null,
        statMods:{incomingDamageMult:0.75,fireRateMult:0.8,speedMult:0.9}
      }
    ];

    const BOSS_ABILITY_DEFS=[
      {
        id:"boss_hyperfocus",
        name:"Hyperfocus",
        rarity:"legendary",
        type:"boss",
        description:"+60% damage, -35% fire rate.",
        requires:null,
        statMods:{damageMult:1.6,fireRateMult:0.65}
      },
      {
        id:"boss_last_stand",
        name:"Last Stand",
        rarity:"legendary",
        type:"boss",
        description:"Under 30% HP: +60% damage & +40% speed. Otherwise -15% damage.",
        requires:null,
        statMods:{lastStand:true,damageMult:0.85}
      },
      {
        id:"boss_titan_hunter",
        name:"Titan Hunter",
        rarity:"legendary",
        type:"boss",
        description:"+60% damage vs bosses, all other enemies +15% HP.",
        requires:null,
        statMods:{bossDamageMult:1.6,enemyHpMult:1.15}
      },
      {
        id:"boss_domain_overclock",
        name:"Domain Overclock",
        rarity:"legendary",
        type:"boss",
        description:"Ult charges 40% faster & lasts longer, but you take +25% damage while ult is down.",
        requires:null,
        statMods:{ultChargeGainMult:1.4,ultDurationMult:1.3,incomingDamageMult:1.25}
      }
    ];

    const CURSE_DEFS=[
      {
        id:"curse_glass_cannon",
        name:"Curse: Glass Cannon",
        rarity:"curse",
        type:"curse",
        description:"Double damage, half max HP.",
        requires:null,
        statMods:{damageMult:2.0,maxHpMult:0.5}
      },
      {
        id:"curse_fragile_speed",
        name:"Curse: Fragile Speed",
        rarity:"curse",
        type:"curse",
        description:"+40% speed, +35% dash distance, +35% damage taken.",
        requires:null,
        statMods:{speedMult:1.4,dashDistanceMult:1.35,incomingDamageMult:1.35}
      },
      {
        id:"curse_blood_price",
        name:"Curse: Blood Price",
        rarity:"curse",
        type:"curse",
        description:"On-hit healing doubled, no heal after waves, +15% damage taken.",
        requires:null,
        statMods:{onHitHealMult:2.0,healAfterWaveMult:0.0,incomingDamageMult:1.15}
      },
      {
        id:"curse_no_limit",
        name:"Curse: No Limit",
        rarity:"curse",
        type:"curse",
        description:"No cap on power count, but all power effects are halved.",
        requires:null,
        statMods:{noLimit:true}
      }
    ];

    normalAbilities=NORMAL_ABILITY_DEFS;
    bossAbilities=BOSS_ABILITY_DEFS;
    curses=CURSE_DEFS;

    /* APPLYING ABILITIES */

    function mulEnemyScale(field,m){
      if(m==null)return;
      enemyScale[field]*=m;
    }

    function applyAbilityToStats(p,ability){
      if(!ability)return;
      const s=ability.statMods||{};
      const effectScale=noLimitMode && ability.id!=="curse_no_limit"?0.5:1;

      function mul(field,m){
        if(m==null)return;
        p[field]*=1+((m-1)*effectScale);
      }
      function add(field,v){
        if(v==null)return;
        p[field]+=v*effectScale;
      }

      // core
      mul("maxHp",s.maxHpMult);
      add("maxHp",s.maxHpAdd);
      mul("damage",s.damageMult);
      add("damage",s.damageAdd);
      mul("fireRate",s.fireRateMult);
      mul("speed",s.speedMult);
      mul("bulletSpeed",s.bulletSpeedMult);
      mul("spread",s.spreadMult);
      add("bulletsPerShot",s.bulletsPerShotAdd);

      mul("meleeDamage",s.meleeDamageMult);
      mul("meleeRange",s.meleeRangeMult);
      mul("meleeCooldown",s.meleeCooldownMult||1);
      add("onHitHeal",s.onHitHealAdd);
      mul("onHitHeal",s.onHitHealMult);
      mul("healAfterWave",s.healAfterWaveMult);

      mul("dashCooldown",s.dashCooldownMult);
      mul("dashDuration",s.dashDurationMult);
      mul("speed",s.dashSpeedMult||1);
      mul("dashDuration",s.dashDistanceMult||1);

      mul("incomingDamageMult",s.incomingDamageMult);
      mul("styleGainMult",s.styleGainMult||1);
      mul("ultChargeGainMult",s.ultChargeGainMult||1);
      mul("ultDamageMult",s.ultDamageMult||1);
      mul("ultSpeedMult",s.ultSpeedMult||1);
      mul("ultFireRateMult",s.ultFireRateMult||1);
      mul("ultMeleeDamageMult",s.ultMeleeDamageMult||1);
      mul("ultMeleeRangeMult",s.ultMeleeRangeMult||1);
      mul("ultBulletSpeedMult",s.ultBulletSpeedMult||1);

      // enemy / global
      mulEnemyScale("hpMult",s.enemyHpMult);
      mulEnemyScale("speedMult",s.enemySpeedMult);
      mulEnemyScale("damageMult",s.enemyDamageMult);
      mulEnemyScale("countMult",s.enemyCountMult);

      // summons
      if(s.summonCountAdd)summonsSummonCount+=s.summonCountAdd;
      if(s.summonPowerMult)p.summonDpsMult*=1+((s.summonPowerMult-1)*effectScale);

      if(s.lastStand)p.lastStandActive=true;
      if(s.bossDamageMult)p.bossDamageMult=(p.bossDamageMult||1)*(1+((s.bossDamageMult-1)*effectScale));
      if(s.damageVsHighHpMult)p.damageVsHighHpMult=(p.damageVsHighHpMult||1)*(1+((s.damageVsHighHpMult-1)*effectScale));
      if(s.damageVsLowHpMult)p.damageVsLowHpMult=(p.damageVsLowHpMult||1)*(1+((s.damageVsLowHpMult-1)*effectScale));
      if(s.ultDurationMult)p.ultDurationMult=(p.ultDurationMult||1)*(1+((s.ultDurationMult-1)*effectScale));

      if(ability.dashMode)p.dashMode=ability.dashMode;
      if(s.meleeHealAdd)p.meleeOnHitHeal+=s.meleeHealAdd*effectScale;
    }

    function recomputeStats(){
      if(!player)return;
      const p=player;
      const prevHpRatio=p.hp>0?(p.hp/p.maxHp):1;

      const diff=DIFFICULTY_SETTINGS[difficulty]||DIFFICULTY_SETTINGS.normal;
      enemyScale.hpMult=diff.enemyHpMult;
      enemyScale.damageMult=diff.enemyDamageMult;
      enemyScale.countMult=diff.enemyCountMult;
      enemyScale.speedMult=1;
      enemyScale.bulletSpeedMult=1;
      enemyScale.bulletDamageMult=1;

      p.maxHp=BASE_STATS.maxHp;
      p.damage=BASE_STATS.damage;
      p.fireRate=BASE_STATS.fireRate;
      p.speed=BASE_STATS.speed;
      p.bulletSpeed=BASE_STATS.bulletSpeed;
      p.bulletsPerShot=BASE_STATS.bulletsPerShot;
      p.spread=BASE_STATS.spread;
      p.pierce=0;
      p.onHitHeal=BASE_STATS.onHitHeal;
      p.healAfterWave=BASE_STATS.healAfterWave;
      p.dashCooldown=BASE_STATS.dashCooldown;
      p.dashDuration=BASE_STATS.dashDuration;
      p.meleeDamage=BASE_STATS.meleeDamage;
      p.meleeRange=BASE_STATS.meleeRange;
      p.meleeCooldown=BASE_STATS.meleeCooldown;
      p.meleeOnHitHeal=BASE_STATS.meleeOnHitHeal;

      p.incomingDamageMult=1;
      p.onHitHealMult=1;
      p.healAfterWaveMult=1;
      p.styleMeter=p.styleMeter||0;
      p.styleMax=100;
      p.styleDecayRate=6;
      p.styleGainMult=1;
      p.ultDamageMult=1;
      p.ultSpeedMult=1;
      p.ultFireRateMult=1;
      p.ultMeleeDamageMult=1;
      p.ultMeleeRangeMult=1;
      p.ultBulletSpeedMult=1;
      p.ultIncomingDamageMult=1;
      p.ultChargeGainMult=p.ultChargeGainMult||1;
      p.ultDurationMult=p.ultDurationMult||1;
      p.bossDamageMult=p.bossDamageMult||1;
      p.damageVsHighHpMult=p.damageVsHighHpMult||1;
      p.damageVsLowHpMult=p.damageVsLowHpMult||1;
      p.lastStandActive=p.lastStandActive||false;
      p.summonDpsMult=p.summonDpsMult||1;
      p.dashMode=p.dashMode||"normal";

      summonsSummonCount=0;
      noLimitMode=activeCurses.includes("curse_no_limit");

      const allIds=[
        ...(p.normalAbilities||[]),
        ...(p.bossAbilities||[]),
        ...activeCurses
      ];
      for(const id of allIds){
        const ability=getAbilityById(id)||getCurseById(id);
        if(!ability)continue;
        applyAbilityToStats(p,ability);
      }

      p.hp=clamp(p.maxHp*prevHpRatio,1,p.maxHp);
    }

    function getAbilityTooltip(ability){
      return ability.description||"";
    }
    function rarityToClass(r){
      if(r==="common")return"rarity-common";
      if(r==="rare")return"rarity-rare";
      if(r==="epic")return"rarity-epic";
      if(r==="legendary")return"rarity-legendary";
      if(r==="curse")return"rarity-legendary";
      return"rarity-common";
    }
    function rarityToLabel(r){
      if(r==="curse")return"Curse";
      return r? r.charAt(0).toUpperCase()+r.slice(1):"Common";
    }

    /* ULT DEFINITIONS */

    const ULT_DEFS={
      "jjk_domain":{
        id:"jjk_domain",
        name:"Cursed Domain",
        type:"domain",
        description:"Large domain circle that rapidly damages enemies inside it.",
        duration:6,
        cooldown:28,
        onCast:(p)=>{
          domainField.active=true;
          domainField.x=p.x;
          domainField.y=p.y;
          domainField.radius=220;
          domainField.type="jjk";
          domainField.color="rgba(90,60,200,0.20)";
          domainField.edgeColor="rgba(220,190,255,0.9)";
          addWhiteFlash(0.7);
          addScreenShake(6,0.45);
          cosmeticStats.totalDomainsCast++;
        }
      },
      "ofa_100":{
        id:"ofa_100",
        name:"OFA 100%",
        type:"self",
        description:"Massive speed and damage boost for a short time.",
        duration:7,
        cooldown:30,
        statMods:{damageMult:2.1,speedMult:1.6,fireRateMult:1.4}
      },
      "demon_mark":{
        id:"demon_mark",
        name:"Demon Mark",
        type:"self",
        description:"Demon Slayer mark: huge melee boost, but you take more damage.",
        duration:7,
        cooldown:30,
        statMods:{meleeDamageMult:2.0,meleeRangeMult:1.3,incomingDamageMult:1.35}
      },
      "gear_fifth":{
        id:"gear_fifth",
        name:"Gear Fifth",
        type:"self",
        description:"Rubber god: bullets bounce & damage is boosted.",
        duration:8,
        cooldown:32,
        statMods:{damageMult:1.6,fireRateMult:1.25}
      },
      "susanoo_guardian":{
        id:"susanoo_guardian",
        name:"Susanoo Guardian",
        type:"self",
        description:"Spectral guardian that blocks bullets & boosts melee.",
        duration:9,
        cooldown:35,
        statMods:{incomingDamageMult:0.5,meleeRangeMult:1.6}
      },
      "cyber_sandevistan":{
        id:"cyber_sandevistan",
        name:"Sandevistan",
        type:"self",
        description:"Time dilation – enemies move in slow motion.",
        duration:6,
        cooldown:30,
        isTimeSlow:true
      },
      "ghoul_rampage":{
        id:"ghoul_rampage",
        name:"Ghoul Rampage",
        type:"self",
        description:"Massive melee and lifesteal.",
        duration:7,
        cooldown:30,
        statMods:{meleeDamageMult:2.2,meleeRangeMult:1.2,onHitHealMult:2.0}
      },
      "flame_domain":{
        id:"flame_domain",
        name:"Flame Ring",
        type:"domain",
        description:"Ring of flame around you that burns enemies.",
        duration:6,
        cooldown:28,
        onCast:(p)=>{
          domainField.active=true;
          domainField.x=p.x;
          domainField.y=p.y;
          domainField.radius=210;
          domainField.type="flame";
          domainField.color="rgba(250,130,60,0.20)";
          domainField.edgeColor="rgba(255,220,160,0.95)";
          addWhiteFlash(0.7);
          addScreenShake(6,0.45);
          cosmeticStats.totalDomainsCast++;
        }
      },
      "bankai_field":{
        id:"bankai_field",
        name:"Bankai Field",
        type:"self",
        description:"Greatly boosts melee & bullet damage, damage taken slightly up.",
        duration:8,
        cooldown:32,
        statMods:{damageMult:1.7,meleeDamageMult:1.7,incomingDamageMult:1.25}
      },
      "haki_burst":{
        id:"haki_burst",
        name:"Haki Burst",
        type:"burst",
        description:"Huge shockwave that stuns & damages nearby enemies.",
        duration:0,
        cooldown:24
      },
      "chimera_shadow_garden":{
        id:"chimera_shadow_garden",
        name:"Shadow Garden",
        type:"domain",
        description:"Shadow domain that buffs summons and shreds enemies.",
        duration:7,
        cooldown:32,
        onCast:(p)=>{
          domainField.active=true;
          domainField.x=p.x;
          domainField.y=p.y;
          domainField.radius=230;
          domainField.type="shadow";
          domainField.color="rgba(40,20,70,0.45)";
          domainField.edgeColor="rgba(190,150,255,0.95)";
          addWhiteFlash(0.75);
          addScreenShake(6,0.5);
          cosmeticStats.totalDomainsCast++;
        }
      },
      "thunder_god_avatar":{
        id:"thunder_god_avatar",
        name:"Thunder God Avatar",
        type:"self",
        description:"Massive speed & chain-lightning bullets.",
        duration:7,
        cooldown:30,
        statMods:{speedMult:1.8,fireRateMult:1.3,damageMult:1.3}
      },
      "orbital_strike":{
        id:"orbital_strike",
        name:"Orbital Strike",
        type:"burst",
        description:"Call down several huge beams on random enemies.",
        duration:0,
        cooldown:26
      }
    };

    function applyUltStats(p,ultDef){
      if(!ultDef)return;
      const s=ultDef.statMods||{};
      function mul(field,m){
        if(m==null)return;
        p[field]*=m;
      }
      mul("damage",s.damageMult);
      mul("speed",s.speedMult);
      mul("fireRate",s.fireRateMult);
      mul("meleeDamage",s.meleeDamageMult);
      mul("meleeRange",s.meleeRangeMult);
      mul("onHitHeal",s.onHitHealMult);
      mul("incomingDamageMult",s.incomingDamageMult);
    }

    function hakiBurstUlt(){
      if(!player)return;
      const range=220;
      for(const e of enemies){
        const d=distance(player.x,player.y,e.x,e.y);
        if(d<=range){
          e.hp-=player.damage*3;
          e.stunTimer=Math.max(e.stunTimer||0,1.2);
        }
      }
      spawnParticles(player.x,player.y,{
        count:40,speedMin:120,speedMax:380,lifeMin:0.3,lifeMax:0.7,sizeMin:3,sizeMax:5,color:"rgba(255,230,180,1)"
      });
      addWhiteFlash(0.5);
      addScreenShake(6,0.35);
    }

    function orbitalStrikeUlt(){
      const targets=enemies.slice();
      if(targets.length===0)return;
      const beams=Math.min(6,targets.length);
      for(let i=0;i<beams;i++){
        const e=targets[Math.floor(Math.random()*targets.length)];
        if(!e)continue;
        spawnParticles(e.x,e.y-40,{
          count:22,speedMin:80,speedMax:260,lifeMin:0.3,lifeMax:0.7,sizeMin:3,sizeMax:5,color:"rgba(190,220,255,1)"
        });
        e.hp-=player.damage*4;
      }
      addWhiteFlash(0.5);
      addScreenShake(6,0.35);
    }

    function tryUseUlt(){
      if(!player||!player.ultId)return;
      const def=ULT_DEFS[player.ultId];
      if(!def)return;
      if(player.ultReady!==true)return;

      player.ultReady=false;
      player.ultCharge=0;
      player.ultCooldownTimer=def.cooldown||25;
      player.ultActiveTimer=(def.duration||0)*(player.ultDurationMult||1);
      addWhiteFlash(0.6);
      addScreenShake(5,0.4);

      if(def.type==="domain" && def.onCast){
        def.onCast(player);
      }else if(def.type==="burst"){
        if(player.ultId==="haki_burst")hakiBurstUlt();
        else if(player.ultId==="orbital_strike")orbitalStrikeUlt();
      }
    }
    /* DASH & MELEE */

    function startDash(){
      if(!player)return;
      if(player.dashCooldownTimer>0)return;
      const dx=mousePos.x-player.x;
      const dy=mousePos.y-player.y;
      const len=Math.hypot(dx,dy)||1;
      const dirX=dx/len;
      const dirY=dy/len;
      const dashSpeed=900;
      player.dashVelX=dirX*dashSpeed;
      player.dashVelY=dirY*dashSpeed;
      player.dashActiveTimer=player.dashDuration;
      player.dashCooldownTimer=player.dashCooldown;
      player.isDashing=true;
      cosmeticStats.totalDashes++;
      if(player.dashMode==="flame"){
        fireBursts.push({x:player.x,y:player.y,life:0.6,radius:60});
      }else if(player.dashMode==="bomb"){
        playerBombs.push({x:player.x,y:player.y,fuse:0.7,radius:80,exploded:false});
      }
      addScreenShake(3,0.18);
    }

    function tryMeleeAttack(){
      if(!player)return;
      if(player.meleeCooldownTimer>0)return;
      const dx=mousePos.x-player.x;
      const dy=mousePos.y-player.y;
      player.meleeAngle=Math.atan2(dy,dx);
      player.meleeSwingTimer=player.meleeSwingDuration;
      player.meleeCooldownTimer=player.meleeCooldown;
      addScreenShake(2,0.1);
      spawnParticles(player.x,player.y,{
        count:10,speedMin:80,speedMax:200,lifeMin:0.2,lifeMax:0.4,sizeMin:2,sizeMax:4,color:"rgba(255,255,255,0.9)"
      });
    }

    /* SHOOTING */

    function spawnBullet(){
      if(!player)return;
      const dx=mousePos.x-player.x;
      const dy=mousePos.y-player.y;
      const baseAngle=Math.atan2(dy,dx);
      const bulletsCount=Math.max(1,Math.round(player.bulletsPerShot));
      const spread=player.spread;

      for(let i=0;i<bulletsCount;i++){
        const offset=(i-(bulletsCount-1)/2);
        const ang=baseAngle+offset*spread*(bulletsCount>1?1:0.6);
        const speed=player.bulletSpeed*(player.ultBulletSpeedMult||1);
        const vx=Math.cos(ang)*speed;
        const vy=Math.sin(ang)*speed;
        bullets.push({
          x:player.x,
          y:player.y,
          vx,vy,
          radius:4,
          damage:player.damage*(player.ultDamageMult||1),
          life:2.2,
          maxLife:2.2,
          pierce:player.pierce+(player.ultPierceBonus||0),
          from:"player"
        });
        cosmeticStats.bulletShots++;
      }
      addScreenShake(1.2,0.08);
    }

    /* WAVE CHALLENGES & REROLLS */

    function resetChallenge(){
      currentChallenge=null;
      if(hudChallenge)hudChallenge.textContent=`Rerolls: ${playerRerolls}`;
    }

    function startWaveChallengeForWave(w){
      if(w<=1){
        resetChallenge();
        return;
      }
      const r=Math.random();
      if(r<0.45){
        // No challenge this wave
        resetChallenge();
        return;
      }
      // Two simple challenge types: no-hit and kill-rush
      const types=["no_hit","kill_rush"];
      const type=types[Math.floor(Math.random()*types.length)];
      if(type==="no_hit"){
        currentChallenge={
          type:"no_hit",
          active:true,
          failed:false,
          completed:false,
          description:"Don't get hit this wave.",
          kills:0,
          targetKills:0,
          timer:0
        };
        showMessage("Challenge: Don't get hit this wave!",2.4);
      }else{
        const target=10+Math.round(w*0.6);
        const time=18;
        currentChallenge={
          type:"kill_rush",
          active:true,
          failed:false,
          completed:false,
          description:`Kill ${target} enemies in ${time}s.`,
          kills:0,
          targetKills:target,
          timer:time
        };
        showMessage(`Challenge: Kill ${target} enemies in ${time}s!`,2.4);
      }
    }

    function completeChallenge(){
      if(!currentChallenge||!currentChallenge.active)return;
      currentChallenge.active=false;
      currentChallenge.completed=true;
      playerRerolls++;
      cosmeticStats.challengesCompleted++;
      cosmeticStats.rerollsEarned++;
      saveCosmeticStats();
      checkCosmeticUnlocks();
      showMessage("Challenge complete! +1 reroll.",2.6);
    }

    function failChallenge(reason){
      if(!currentChallenge||!currentChallenge.active)return;
      currentChallenge.active=false;
      currentChallenge.failed=true;
      if(reason)showMessage(reason,2.2);
    }

    function onPlayerDamagedForChallenge(){
      if(!currentChallenge||!currentChallenge.active)return;
      if(currentChallenge.type==="no_hit"){
        failChallenge("Challenge failed: you were hit.");
      }
    }

    function onEnemyKilledForChallenge(){
      if(!currentChallenge||!currentChallenge.active)return;
      if(currentChallenge.type==="kill_rush"){
        currentChallenge.kills++;
        if(currentChallenge.kills>=currentChallenge.targetKills){
          completeChallenge();
        }
      }
    }

    function updateChallenge(dt){
      if(!currentChallenge||!currentChallenge.active)return;
      if(currentChallenge.type==="kill_rush"){
        currentChallenge.timer-=dt;
        if(currentChallenge.timer<=0 && currentChallenge.kills<currentChallenge.targetKills){
          failChallenge("Challenge failed: too slow.");
        }
      }
    }

    function updateRerollUI(){
      rerollButton.textContent=`Reroll (${playerRerolls})`;
      rerollButton.disabled=playerRerolls<=0;
    }

    /* UPGRADE PANEL & OPTIONS (3 CHOICES) */

    function isBossWave(num){return num>0 && num%5===0;}

    function weightedRandomChoice(pool){
      if(pool.length===0)return null;
      let total=0;
      for(const a of pool){
        let w=1;
        if(a.rarity==="common")w=3;
        else if(a.rarity==="rare")w=2.2;
        else if(a.rarity==="epic")w=1.4;
        else if(a.rarity==="legendary"||a.rarity==="curse")w=0.7;
        total+=w;
        a._w=w;
      }
      let r=Math.random()*total;
      for(const a of pool){
        r-=a._w;
        if(r<=0)return a;
      }
      return pool[pool.length-1];
    }

    function generateUpgradeOptionsForWave(){
      const bossWave=isBossWave(wave);
      const options=[];
      const playerIds=[
        ...(player.normalAbilities||[]),
        ...(player.bossAbilities||[]),
        ...activeCurses
      ];
      const MAX_OPTIONS=3;

      if(!bossWave){
        let pool=NORMAL_ABILITY_DEFS.filter(a=>{
          if(playerIds.includes(a.id))return false;
          if(a.requires && !playerHasAbility(a.requires))return false;
          if(a.rarity==="legendary"||a.rarity==="curse")return false;
          return true;
        });
        pool=shuffled(pool);
        while(options.length<MAX_OPTIONS && pool.length>0){
          const choice=weightedRandomChoice(pool);
          if(!choice)break;
          options.push(choice);
          pool=pool.filter(x=>x.id!==choice.id);
        }
      }else{
        // Boss wave: guarantee at least 1 legendary and 1 curse if possible
        let legendaryPool=[
          ...NORMAL_ABILITY_DEFS.filter(a=>a.rarity==="legendary"),
          ...BOSS_ABILITY_DEFS
        ].filter(a=>{
          if(playerIds.includes(a.id))return false;
          if(a.requires && !playerHasAbility(a.requires))return false;
          return true;
        });

        let cursePool=CURSE_DEFS.filter(a=>{
          if(playerIds.includes(a.id))return false;
          if(a.requires && !playerHasAbility(a.requires))return false;
          return true;
        });

        const normalPool=NORMAL_ABILITY_DEFS.filter(a=>{
          if(a.rarity==="legendary"||a.rarity==="curse")return false;
          if(playerIds.includes(a.id))return false;
          if(a.requires && !playerHasAbility(a.requires))return false;
          return true;
        });

        const leg=weightedRandomChoice(legendaryPool);
        if(leg)options.push(leg);

        const cur=weightedRandomChoice(cursePool);
        if(cur && !options.find(o=>o.id===cur.id))options.push(cur);

        let pool=shuffled(normalPool);
        while(options.length<MAX_OPTIONS && pool.length>0){
          const pick=weightedRandomChoice(pool);
          if(!pick)break;
          if(!options.find(o=>o.id===pick.id)){
            options.push(pick);
          }
          pool=pool.filter(x=>x.id!==pick.id);
        }
      }
      return options;
    }

    function renderUpgradeOptions(opts){
      upgradesContainer.innerHTML="";
      if(opts.length===0){
        const msg=document.createElement("div");
        msg.style.fontSize="12px";
        msg.style.opacity="0.8";
        msg.textContent="No valid upgrades available – everything you can take right now is exhausted.";
        upgradesContainer.appendChild(msg);
        return;
      }
      opts.forEach(opt=>{
        const rarityClass=rarityToClass(opt.rarity);
        const rarityLabel=rarityToLabel(opt.rarity);
        const div=document.createElement("button");
        div.className=`upgradeButton card-rarity-${opt.rarity==="curse"?"legendary":opt.rarity}`;
        div.innerHTML=`
          <div class="upgradeTopRow">
            <span class="upgradeName">${opt.name}</span>
            <span class="rarityBadge ${rarityClass}">${rarityLabel}</span>
          </div>
          <div class="upgradeDesc">${getAbilityTooltip(opt)}</div>
        `;
        div.addEventListener("click",()=>chooseUpgrade(opt));
        upgradesContainer.appendChild(div);
      });
    }

    function openUpgradePanel(){
      const opts=generateUpgradeOptionsForWave();
      upgradePanel.style.display="flex";
      replaceTarget=null;
      renderUpgradeOptions(opts);
      updateRerollUI();
      gameState="upgrading";
      showMessage("Choose a power or skip.",2.2);
    }

    skipButton.addEventListener("click",()=>{
      upgradePanel.style.display="none";
      gameState="intermission";
      intermissionTimer=1.0;
      showMessage("Skipped power. Next wave incoming.",2.0);
    });

    rerollButton.addEventListener("click",()=>{
      if(playerRerolls<=0)return;
      playerRerolls--;
      const opts=generateUpgradeOptionsForWave();
      renderUpgradeOptions(opts);
      updateRerollUI();
      showMessage("Rerolled power choices.",1.5);
    });

    let intermissionTimer=0;
    let nextUpgradeDelayTimer=0;
    let upgradePending=false;

    function applyUpgradeNoReplace(ability){
      if(!player)return;
      if(ability.type==="curse"||ability.rarity==="curse"){
        if(!activeCurses.includes(ability.id))activeCurses.push(ability.id);
      }else if(ability.type==="boss"){
        if(!player.bossAbilities.includes(ability.id))player.bossAbilities.push(ability.id);
      }else{
        if(!player.normalAbilities.includes(ability.id))player.normalAbilities.push(ability.id);
      }
      cosmeticStats.cursesTaken=activeCurses.length;
      recomputeStats();
      updateHUDAbilities();
      updateStatsPanel();
      saveCosmeticStats();
      checkCosmeticUnlocks();
    }

    function chooseUpgrade(ability){
      if(!player)return;
      const isCurse=ability.type==="curse"||ability.rarity==="curse";
      const isBoss=ability.type==="boss" || isCurse;
      let currentCount=isBoss?(player.bossAbilities.length+activeCurses.length):player.normalAbilities.length;
      const cap=isBoss?BOSS_POWER_CAP:NORMAL_POWER_CAP;

      if(currentCount>=cap && !noLimitMode){
        replaceTarget={ability,slotType:isBoss?"boss":"normal"};
        showMessage("Choose a power below to replace.",3);
        return;
      }

      applyUpgradeNoReplace(ability);
      upgradePanel.style.display="none";
      gameState="intermission";
      intermissionTimer=1.0;
      showMessage(`${ability.name} equipped.`,2.2);
    }

    function handleSlotClick(slotType,id){
      if(!replaceTarget)return;
      if(slotType!==replaceTarget.slotType && !(slotType==="boss" && replaceTarget.slotType==="boss"))return;

      if(slotType==="normal"){
        player.normalAbilities=player.normalAbilities.filter(x=>x!==id);
      }else{
        if(activeCurses.includes(id)){
          activeCurses=activeCurses.filter(x=>x!==id);
        }else{
          player.bossAbilities=player.bossAbilities.filter(x=>x!==id);
        }
      }

      const newAbility=replaceTarget.ability;
      replaceTarget=null;
      applyUpgradeNoReplace(newAbility);
      upgradePanel.style.display="none";
      gameState="intermission";
      intermissionTimer=1.0;
      showMessage(`Replaced with ${newAbility.name}.`,2.2);
    }

    function updateHUDAbilities(){
      normalAbilitiesListEl.innerHTML="";
      bossAbilitiesListEl.innerHTML="";

      const makeSlot=(ability,slotType)=>{
        const span=document.createElement("span");
        span.className=`abilitySlot card-rarity-${ability.rarity==="curse"?"legendary":ability.rarity}`;
        span.textContent=ability.name;
        span.title=getAbilityTooltip(ability);
        span.addEventListener("click",()=>{
          handleSlotClick(slotType,ability.id);
        });
        return span;
      };

      if(player && player.normalAbilities){
        for(const id of player.normalAbilities){
          const a=getAbilityById(id)||getCurseById(id);
          if(!a)continue;
          normalAbilitiesListEl.appendChild(makeSlot(a,"normal"));
        }
      }
      if(player){
        const allBoss=[...(player.bossAbilities||[]),...activeCurses];
        for(const id of allBoss){
          const a=getAbilityById(id)||getCurseById(id);
          if(!a)continue;
          bossAbilitiesListEl.appendChild(makeSlot(a,"boss"));
        }
      }
    }

    function updateStatsPanel(){
      if(!player)return;
      const p=player;
      statsContentEl.innerHTML="";
      const rows=[
        ["HP",`${Math.round(p.hp)}/${Math.round(p.maxHp)}`],
        ["Damage",Math.round(p.damage)],
        ["Fire rate",p.fireRate.toFixed(2)+"/s"],
        ["Bullet speed",Math.round(p.bulletSpeed)],
        ["Bullets/shot",p.bulletsPerShot.toFixed(1)],
        ["Spread",p.spread.toFixed(2)],
        ["Move speed",Math.round(p.speed)],
        ["Melee dmg",Math.round(p.meleeDamage)],
        ["Melee range",Math.round(p.meleeRange)],
        ["Dash cd",p.dashCooldown.toFixed(2)+"s"],
        ["Dash mode",p.dashMode],
        ["Heal on hit",p.onHitHeal.toFixed(1)],
        ["Melee heal",p.meleeOnHitHeal.toFixed(1)],
        ["Heal after wave",(p.healAfterWave*p.healAfterWaveMult).toFixed(1)],
        ["Incoming dmg x",p.incomingDamageMult.toFixed(2)],
        ["Ult charge",Math.round(p.ultCharge||0)+"%"],
        ["Ult ready",p.ultReady?"Yes":"No"],
        ["Summon power x",p.summonDpsMult.toFixed(2)],
        ["Rerolls",playerRerolls]
      ];
      for(const [k,v] of rows){
        const div=document.createElement("div");
        div.className="statRow";
        div.innerHTML=`<span>${k}</span><span>${v}</span>`;
        statsContentEl.appendChild(div);
      }
    }
    /* ENEMIES & WAVES */

    let currentBoss=null;
    let waveActive=false;
    let enemiesSpawned=false;
    let timeInWave=0;

    function createEnemy(type,opts={}){
      const e={
        id:enemyIdCounter++,
        type,
        x:opts.x||0,
        y:opts.y||0,
        radius:opts.radius||16,
        color:opts.color||"#ff6666",
        hp:opts.hp||40,
        maxHp:opts.hp||40,
        speed:opts.speed||80,
        vx:0,vy:0,
        attackTimer:0.5,
        attackCooldown:opts.attackCooldown||1.2,
        stunTimer:0,
        contactDamage:opts.contactDamage!=null?opts.contactDamage:6,
        bulletDamage:opts.bulletDamage!=null?opts.bulletDamage:5,
        bulletSpeed:opts.bulletSpeed||260,
        isBoss:false,
        bossId:null,
        pattern:opts.pattern||"chase",
        domainCooldown:opts.domainCooldown||0
      };
      return e;
    }

    function spawnEnemyAtEdge(type,extra={}){
      const side=Math.floor(Math.random()*4);
      let x,y;
      if(side===0){x=-20;y=Math.random()*canvas.height;}
      else if(side===1){x=canvas.width+20;y=Math.random()*canvas.height;}
      else if(side===2){x=Math.random()*canvas.width;y=-20;}
      else{x=Math.random()*canvas.width;y=canvas.height+20;}
      const e=createEnemy(type,{x,y,...extra});
      enemies.push(e);
      return e;
    }

    function spawnBossForWave(){
      const idx=Math.floor(wave/5-1);
      const def=BOSS_TEMPLATES[idx%BOSS_TEMPLATES.length];
      const baseHp=450+wave*45;
      const boss=createEnemy("boss",{
        x:canvas.width/2,
        y:canvas.height*0.25,
        radius:40,
        hp:baseHp*enemyScale.hpMult,
        speed:90*enemyScale.speedMult,
        color:def.color,
        contactDamage:18*enemyScale.damageMult,
        bulletDamage:10*enemyScale.bulletDamageMult,
        bulletSpeed:300*enemyScale.bulletSpeedMult,
        attackCooldown:1.4
      });
      boss.isBoss=true;
      boss.bossId=def.id;
      boss.pattern="boss_"+def.id;
      boss.attackTimer=2.0;
      boss.domainCooldown=10+Math.random()*5;
      enemies.push(boss);
      currentBoss=boss;
      showMessage(`Boss: ${def.name}`,3);
    }

    function spawnWaveEnemies(w){
      const bossWave=isBossWave(w);
      const baseCount=Math.round(5+w*1.3*enemyScale.countMult);

      for(let i=0;i<baseCount;i++){
        let type="grunt";
        const r=Math.random();
        if(r<0.15)type="rusher";
        else if(r<0.3)type="bomber";
        else if(r<0.45)type="sniper";

        const hp=(40+ w*6)*enemyScale.hpMult;
        let speed=95;
        if(type==="rusher")speed=130;
        else if(type==="bomber")speed=75;
        const contactDamage=(type==="bomber"?10:7)*enemyScale.damageMult;
        const bulletDamage=5*enemyScale.bulletDamageMult;
        spawnEnemyAtEdge(type,{
          hp,
          speed:speed*enemyScale.speedMult,
          contactDamage,
          bulletDamage
        });
      }

      if(bossWave){
        spawnBossForWave();
        for(let i=0;i<4;i++){
          spawnEnemyAtEdge("grunt",{
            hp:(60+ w*5)*enemyScale.hpMult,
            speed:90*enemyScale.speedMult,
            contactDamage:8*enemyScale.damageMult,
            bulletDamage:5*enemyScale.bulletDamageMult
          });
        }
      }else if(w%3===0){
        const t=MINI_BOSS_TEMPLATES[Math.floor(Math.random()*MINI_BOSS_TEMPLATES.length)];
        const mini=createEnemy("miniboss",{
          x:canvas.width/2,
          y:canvas.height*0.2,
          radius:28,
          hp:(220+ w*25)*enemyScale.hpMult,
          speed:90*enemyScale.speedMult,
          color:t.color,
          contactDamage:12*enemyScale.damageMult,
          bulletDamage:7*enemyScale.bulletDamageMult,
          bulletSpeed:280*enemyScale.bulletSpeedMult,
          attackCooldown:1.0,
          pattern:t.pattern
        });
        enemies.push(mini);
      }

      enemiesSpawned=true;
      waveActive=true;
    }

    function startNextWave(){
      wave++;
      enemies.length=0;
      bullets.length=0;
      enemyBullets.length=0;
      summons.length=0;
      fireBursts.length=0;
      playerBombs.length=0;
      slowFields.length=0;
      currentBoss=null;
      timeInWave=0;
      enemiesSpawned=false;
      waveActive=false;

      spawnWaveEnemies(wave);
      startWaveChallengeForWave(wave);
      gameState="playing";
      showMessage(isBossWave(wave)?`Boss Wave ${wave}`:`Wave ${wave}`,2.2);

      if(cosmeticStats.maxWaveEver<wave){
        cosmeticStats.maxWaveEver=wave;
        saveCosmeticStats();
        checkCosmeticUnlocks();
      }
    }

    function onWaveCleared(){
      if(!player)return;
      const heal=player.healAfterWave*player.healAfterWaveMult;
      if(heal>0){
        player.hp=Math.min(player.maxHp,player.hp+heal);
        spawnParticles(player.x,player.y,{
          count:14,speedMin:40,speedMax:140,lifeMin:0.4,lifeMax:0.8,sizeMin:2,sizeMax:4,color:"rgba(160,255,200,1)"
        });
      }
      upgradePending=true;
      nextUpgradeDelayTimer=0.5;
    }

    /* SUMMONS & FIELDS */

    function updateSummons(dt){
      if(!player)return;
      const desiredCount=summonsSummonCount;
      while(summons.length<desiredCount){
        summons.push({
          x:player.x+Math.random()*40-20,
          y:player.y+Math.random()*40-20,
          angle:Math.random()*Math.PI*2,
          orbitRadius:40+Math.random()*20,
          attackTimer:Math.random(),
          color:"#574684"
        });
      }
      while(summons.length>desiredCount){
        summons.pop();
      }

      for(const s of summons){
        s.angle+=dt*1.3;
        const targetRadius=s.orbitRadius;
        const tx=player.x+Math.cos(s.angle)*targetRadius;
        const ty=player.y+Math.sin(s.angle)*targetRadius;
        s.x+=(tx-s.x)*dt*6;
        s.y+=(ty-s.y)*dt*6;
        s.attackTimer-=dt;
        if(s.attackTimer<=0){
          s.attackTimer=0.55+Math.random()*0.2;
          const target=enemies.filter(e=>!e.isBoss)[0]||enemies[0];
          if(target){
            const dx=target.x-s.x;
            const dy=target.y-s.y;
            const ang=Math.atan2(dy,dx);
            const sp=420;
            bullets.push({
              x:s.x,y:s.y,
              vx:Math.cos(ang)*sp,
              vy:Math.sin(ang)*sp,
              radius:3,
              damage:player.damage*0.55*player.summonDpsMult,
              life:1.2,maxLife:1.2,
              pierce:0,
              from:"summon"
            });
            spawnParticles(s.x,s.y,{
              count:4,speedMin:60,speedMax:110,lifeMin:0.2,lifeMax:0.4,sizeMin:1.5,sizeMax:3,color:"rgba(160,140,255,1)"
            });
          }
        }
      }
    }

    function updateFireBursts(dt){
      for(let i=fireBursts.length-1;i>=0;i--){
        const f=fireBursts[i];
        f.life-=dt;
        if(f.life<=0){fireBursts.splice(i,1);continue;}
        for(const e of enemies){
          const dx=e.x-f.x;
          const dy=e.y-f.y;
          const dist=Math.hypot(dx,dy);
          if(dist<f.radius+e.radius){
            e.hp-=player.damage*1.2*dt;
          }
        }
      }
    }

    function explosionDamage(x,y,radius,mult){
      if(!player)return;
      for(const e of enemies){
        const d=distance(x,y,e.x,e.y);
        if(d<radius+e.radius){
          e.hp-=player.damage*mult;
        }
      }
    }

    function updatePlayerBombs(dt){
      for(let i=playerBombs.length-1;i>=0;i--){
        const b=playerBombs[i];
        b.fuse-=dt;
        if(b.fuse<=0 && !b.exploded){
          b.exploded=true;
          addScreenShake(5,0.3);
          addWhiteFlash(0.4);
          spawnParticles(b.x,b.y,{
            count:32,speedMin:80,speedMax:260,lifeMin:0.3,lifeMax:0.7,sizeMin:3,sizeMax:5,color:"rgba(255,210,140,1)"
          });
          explosionDamage(b.x,b.y,b.radius,3.2); // bombs now do real damage
        }
        if(b.exploded && b.fuse<-0.4){
          playerBombs.splice(i,1);
        }
      }
    }

    function updateSlowFields(dt){
      for(let i=slowFields.length-1;i>=0;i--){
        const f=slowFields[i];
        f.life-=dt;
        if(f.life<=0)slowFields.splice(i,1);
      }
    }

    function updateDomain(dt){
      if(!domainField.active || !player)return;
      const d=domainField;

      // Maintain radius softly
      d.radius=Math.max(160,d.radius-10*dt);

      // Damage based on domain type
      let mult=2.4;
      if(d.type==="flame")mult=2.0;
      else if(d.type==="shadow")mult=2.8;
      else if(d.type==="gojo")mult=3.0;
      else if(d.type==="mahito")mult=2.6;

      for(const e of enemies){
        const dist=distance(d.x,d.y,e.x,e.y);
        if(dist<d.radius+e.radius){
          e.hp-=player.damage*mult*dt;
        }
      }
    }

    function drawDomain(){
      if(!domainField.active)return;
      const d=domainField;
      ctx.save();
      ctx.beginPath();
      ctx.arc(d.x,d.y,d.radius,0,Math.PI*2);
      ctx.fillStyle=d.color;
      ctx.fill();
      ctx.lineWidth=3;
      ctx.strokeStyle=d.edgeColor;
      ctx.stroke();
      ctx.restore();
    }

    /* ENEMY LOGIC */

    function updateEnemies(dt){
      if(!player)return;
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        if(e.stunTimer>0)e.stunTimer-=dt;

        const dx=player.x-e.x;
        const dy=player.y-e.y;
        const dist=Math.hypot(dx,dy)||1;
        let moveFac=1;

        if(player.ultId==="cyber_sandevistan" && player.ultActiveTimer>0){
          moveFac*=0.35;
        }
        for(const f of slowFields){
          const d=distance(e.x,e.y,f.x,f.y);
          if(d<f.radius)moveFac*=0.65;
        }
        if(e.stunTimer>0)moveFac*=0.25;

        if(e.isBoss){
          updateBoss(e,dt,dx,dy,dist,moveFac);
        }else{
          updateNormalEnemy(e,dt,dx,dy,dist,moveFac);
        }

        // Player contact
        const pd=dist;
        if(pd<player.radius+e.radius){
          if(e.isBoss && e.bossId==="mahito"){
            player.mahitoTouchStacks++;
            spawnParticles(player.x,player.y,{
              count:16,speedMin:60,speedMax:180,lifeMin:0.25,lifeMax:0.6,sizeMin:2,sizeMax:4,color:"rgba(200,130,255,1)"
            });
            showMessage(`Mahito touched your soul (${player.mahitoTouchStacks}/2)`,1.6);
            if(player.mahitoTouchStacks>=2){
              player.hp=0;
              handleGameOver();
              showMessage("Your soul was reshaped by Mahito.",3.2);
            }
          }else{
            damagePlayer(e.contactDamage*enemyScale.damageMult);
          }
          const push=(player.radius+e.radius-pd)*0.5;
          const nx=dx/dist;
          const ny=dy/dist;
          player.x+=-nx*push;
          player.y+=-ny*push;
          e.x+=nx*push;
          e.y+=ny*push;
        }

        if(e.hp<=0){
          const wasBoss=e.isBoss;
          if(wasBoss){
            cosmeticStats.bossesKilled++;
            if(playerHasAbility("shadow_army_commander")){
              cosmeticStats.defeatedBossWithShadowCommanderOnce=true;
            }
          }
          runKills++;
          onEnemyKilledForChallenge();
          spawnParticles(e.x,e.y,{
            count:18,speedMin:70,speedMax:240,lifeMin:0.3,lifeMax:0.7,sizeMin:3,sizeMax:6,color:wasBoss?"rgba(255,220,160,1)":"rgba(255,150,150,1)"
          });
          enemies.splice(i,1);
        }
      }
    }

    function updateNormalEnemy(e,dt,dx,dy,dist,moveFac){
      if(e.type==="sniper"){
        const desired=260;
        let dir=0;
        if(dist<desired-40)dir=-1;
        else if(dist>desired+40)dir=1;
        const nx=dx/dist;
        const ny=dy/dist;
        e.vx=nx*e.speed*dir*moveFac;
        e.vy=ny*e.speed*dir*moveFac;
      }else{
        const nx=dx/dist;
        const ny=dy/dist;
        e.vx=nx*e.speed*moveFac;
        e.vy=ny*e.speed*moveFac;
      }
      e.x+=e.vx*dt;
      e.y+=e.vy*dt;
      e.x=clamp(e.x,e.radius,canvas.width-e.radius);
      e.y=clamp(e.y,e.radius,canvas.height-e.radius);

      e.attackTimer-=dt;
      if(e.attackTimer<=0){
        e.attackTimer=e.attackCooldown;
        if(e.type==="sniper"){
          spawnEnemyBullet(e,dx,dy,1.0);
        }else if(e.type==="bomber"){
          if(dist<260){
            spawnEnemyBulletCone(e,3,0.25);
          }
        }else if(e.type==="rusher"){
          if(dist<220){
            spawnEnemyBulletCone(e,2,0.2);
          }
        }
      }
    }

    function updateBoss(e,dt,dx,dy,dist,moveFac){
      const nx=dx/dist;
      const ny=dy/dist;
      e.x+=nx*e.speed*0.6*moveFac*dt;
      e.y+=ny*e.speed*0.6*moveFac*dt;
      e.x=clamp(e.x,e.radius,canvas.width-e.radius);
      e.y=clamp(e.y,e.radius,canvas.height-e.radius);

      e.attackTimer-=dt;
      e.domainCooldown-=dt;

      if(e.bossId==="mahito"){
        if(e.domainCooldown<=0){
          e.domainCooldown=18+Math.random()*5;
          domainField.active=true;
          domainField.x=e.x;
          domainField.y=e.y;
          domainField.radius=240;
          domainField.type="mahito";
          domainField.color="rgba(130,70,210,0.25)";
          domainField.edgeColor="rgba(230,210,255,0.95)";
          addWhiteFlash(0.6);
          addScreenShake(6,0.4);
          showMessage("Mahito cast Domain Expansion",2.4);
        }
        if(e.attackTimer<=0){
          e.attackTimer=1.4;
          spawnEnemyBulletSpiral(e,10);
        }
      }else if(e.bossId==="itachi"){
        if(e.domainCooldown<=0){
          e.domainCooldown=20+Math.random()*6;
          bossGenjutsuTimer=GENJUTSU_DURATION;
          addWhiteFlash(0.5);
          showMessage("Itachi trapped you in Genjutsu",2.4);
        }
        if(e.attackTimer<=0){
          e.attackTimer=1.6;
          spawnEnemyBulletCone(e,6,0.3);
        }
      }else if(e.bossId==="gojo"){
        if(e.domainCooldown<=0){
          e.domainCooldown=22+Math.random()*4;
          domainField.active=true;
          domainField.x=e.x;
          domainField.y=e.y;
          domainField.radius=260;
          domainField.type="gojo";
          domainField.color="rgba(90,200,255,0.15)";
          domainField.edgeColor="rgba(200,240,255,0.95)";
          addWhiteFlash(0.7);
          addScreenShake(7,0.4);
          showMessage("Gojo: Unlimited Void!",2.4);
        }
        if(e.attackTimer<=0){
          e.attackTimer=1.2;
          spawnEnemyBulletSpiral(e,12);
        }
      }else{
        if(e.attackTimer<=0){
          e.attackTimer=1.1;
          spawnEnemyBulletCone(e,5,0.35);
          addScreenShake(3,0.15);
        }
      }
    }

    function spawnEnemyBullet(e,dx,dy,speedMult=1){
      const dist=Math.hypot(dx,dy)||1;
      const nx=dx/dist;
      const ny=dy/dist;
      const sp=e.bulletSpeed*enemyScale.bulletSpeedMult*speedMult;
      enemyBullets.push({
        x:e.x,y:e.y,
        vx:nx*sp,
        vy:ny*sp,
        radius:4,
        damage:e.bulletDamage*enemyScale.bulletDamageMult,
        life:4
      });
    }

    function spawnEnemyBulletCone(e,count,spread){
      const baseAngle=Math.atan2(player.y-e.y,player.x-e.x);
      const totalSpread=spread*2;
      for(let i=0;i<count;i++){
        const t=count===1?0:(i/(count-1)-0.5);
        const ang=baseAngle+t*totalSpread;
        const sp=e.bulletSpeed*enemyScale.bulletSpeedMult;
        enemyBullets.push({
          x:e.x,y:e.y,
          vx:Math.cos(ang)*sp,
          vy:Math.sin(ang)*sp,
          radius:4,
          damage:e.bulletDamage*enemyScale.bulletDamageMult,
          life:4
        });
      }
    }

    function spawnEnemyBulletSpiral(e,count){
      const baseAngle=performance.now()/400;
      for(let i=0;i<count;i++){
        const ang=baseAngle+i*(Math.PI*2/count);
        const sp=e.bulletSpeed*enemyScale.bulletSpeedMult*0.9;
        enemyBullets.push({
          x:e.x,y:e.y,
          vx:Math.cos(ang)*sp,
          vy:Math.sin(ang)*sp,
          radius:4,
          damage:e.bulletDamage*enemyScale.bulletDamageMult,
          life:4
        });
      }
    }

    /* DAMAGE & BULLETS */

    function damagePlayer(amount){
      if(!player)return;
      let dmg=amount*player.incomingDamageMult;
      if(player.lastStandActive && player.hp/player.maxHp<0.3){
        dmg*=0.6;
      }
      player.hp-=dmg;
      onPlayerDamagedForChallenge();
      addScreenShake(4,0.18);
      spawnParticles(player.x,player.y,{
        count:12,speedMin:60,speedMax:160,lifeMin:0.25,lifeMax:0.5,sizeMin:2,sizeMax:4,color:"rgba(255,120,120,0.95)"
      });
      if(player.hp<=0){
        player.hp=0;
        handleGameOver();
      }
    }

    function updateBullets(dt){
      // player & summon bullets
      for(let i=bullets.length-1;i>=0;i--){
        const b=bullets[i];
        b.x+=b.vx*dt;
        b.y+=b.vy*dt;
        b.life-=dt;
        if(b.life<=0 || b.x<-40 || b.x>canvas.width+40 || b.y<-40 || b.y>canvas.height+40){
          bullets.splice(i,1);
          continue;
        }
        addBulletTrailFX(b);
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          const dx=e.x-b.x;
          const dy=e.y-b.y;
          const d=Math.hypot(dx,dy);
          if(d<e.radius+b.radius){
            let dmg=b.damage;
            const hpRatio=e.hp/e.maxHp;
            if(player.damageVsHighHpMult && hpRatio>0.7)dmg*=player.damageVsHighHpMult;
            if(player.damageVsLowHpMult && hpRatio<0.3)dmg*=player.damageVsLowHpMult;
            if(player.bossDamageMult && e.isBoss)dmg*=player.bossDamageMult;
            e.hp-=dmg;

            // on-hit heal
            const heal=(player.onHitHeal)*player.onHitHealMult;
            if(heal>0)player.hp=Math.min(player.maxHp,player.hp+heal);

            // tactical grenade explosions
            if(playerHasAbility("tactical_grenade")){
              explosionDamage(b.x,b.y,65,1.4);
              spawnParticles(b.x,b.y,{
                count:16,speedMin:80,speedMax:220,lifeMin:0.25,lifeMax:0.6,sizeMin:2,sizeMax:4,color:"rgba(255,210,140,1)"
              });
              addScreenShake(3,0.16);
            }

            player.styleMeter+=2*player.styleGainMult;
            if(e.hp<=0)player.styleMeter+=6*player.styleGainMult;

            if(b.pierce>0)b.pierce--; else{bullets.splice(i,1);break;}
          }
        }
      }

      // enemy bullets
      for(let i=enemyBullets.length-1;i>=0;i--){
        const b=enemyBullets[i];
        let slowFactor=1;
        if(player && player.ultId==="cyber_sandevistan" && player.ultActiveTimer>0){
          slowFactor=0.35;
        }
        b.x+=b.vx*dt*slowFactor;
        b.y+=b.vy*dt*slowFactor;
        b.life-=dt;
        if(b.life<=0 || b.x<-40 || b.x>canvas.width+40 || b.y<-40 || b.y>canvas.height+40){
          enemyBullets.splice(i,1);
          continue;
        }
        if(player){
          const dx=player.x-b.x;
          const dy=player.y-b.y;
          const d=Math.hypot(dx,dy);
          if(d<player.radius+b.radius && !player.isDashing){
            damagePlayer(b.damage);
            enemyBullets.splice(i,1);
          }
        }
      }
    }

    /* PLAYER UPDATE + MELEE */

    function processMeleeHit(){
      if(!player)return;
      const p=player;
      const ang=p.meleeAngle;
      const arc=p.meleeArc;
      for(const e of enemies){
        const dx=e.x-p.x;
        const dy=e.y-p.y;
        const d=Math.hypot(dx,dy);
        if(d>p.meleeRange+e.radius)continue;
        const a=Math.atan2(dy,dx);
        const diff=Math.abs(angleDiff(a,ang));
        if(diff<arc*0.5){
          const dmg=p.meleeDamage*(p.ultMeleeDamageMult||1);
          e.hp-=dmg;
          const heal=(p.meleeOnHitHeal+p.onHitHeal)*p.onHitHealMult;
          if(heal>0)p.hp=Math.min(p.maxHp,p.hp+heal);
          cosmeticStats.meleeHits++;
          spawnParticles(e.x,e.y,{
            count:9,speedMin:80,speedMax:200,lifeMin:0.2,lifeMax:0.4,sizeMin:2,sizeMax:4,color:"rgba(255,255,255,0.9)"
          });
        }
      }
    }

    function getStyleRank(){
      if(!player)return"C";
      const t=player.styleMeter/player.styleMax;
      if(t>=0.9)return"S";
      if(t>=0.65)return"A";
      if(t>=0.4)return"B";
      return"C";
    }

    function updatePlayer(dt){
      if(!player)return;

      // Ult stat buffs
      if(player.ultActiveTimer>0 && !player.ultStatsApplied){
        const def=ULT_DEFS[player.ultId];
        if(def && def.statMods){
          applyUltStats(player,def);
        }
        player.ultStatsApplied=true;
      }
      if(player.ultActiveTimer>0){
        player.ultActiveTimer-=dt;
        if(player.ultActiveTimer<=0){
          player.ultActiveTimer=0;
          domainField.active=false;
          if(player.ultStatsApplied){
            player.ultStatsApplied=false;
            recomputeStats();
          }
        }
      }

      const speed=player.speed*(player.ultSpeedMult||1);
      let vx=0,vy=0;
      if(keys["w"]||keys["arrowup"])vy-=1;
      if(keys["s"]||keys["arrowdown"])vy+=1;
      if(keys["a"]||keys["arrowleft"])vx-=1;
      if(keys["d"]||keys["arrowright"])vx+=1;
      const len=Math.hypot(vx,vy);
      if(len>0){vx/=len;vy/=len;}

      if(!player.isDashing){
        player.x+=vx*speed*dt;
        player.y+=vy*speed*dt;
      }else{
        player.x+=player.dashVelX*dt;
        player.y+=player.dashVelY*dt;
      }

      player.x=clamp(player.x,player.radius,canvas.width-player.radius);
      player.y=clamp(player.y,player.radius,canvas.height-player.radius);

      player.shootTimer-=dt;
      if(mouseDown && gameState==="playing"){
        const rate=player.fireRate*(player.ultFireRateMult||1);
        if(player.shootTimer<=0){
          player.shootTimer=1/Math.max(0.1,rate);
          spawnBullet();
        }
      }

      if(player.dashCooldownTimer>0)player.dashCooldownTimer-=dt;
      if(player.isDashing){
        player.dashActiveTimer-=dt;
        if(player.dashActiveTimer<=0){
          player.isDashing=false;
        }
      }

      if(player.meleeCooldownTimer>0)player.meleeCooldownTimer-=dt;
      if(player.meleeSwingTimer>0){
        player.meleeSwingTimer-=dt;
        if(!player.meleeHitApplied){
          processMeleeHit();      // melee now actually damages once per swing
          player.meleeHitApplied=true;
        }
        if(player.meleeSwingTimer<=0){
          player.meleeHitApplied=false;
        }
      }

      if(player.ultCooldownTimer>0)player.ultCooldownTimer-=dt;
      if(!player.ultReady){
        player.ultCharge+=dt*4*player.ultChargeGainMult;
        if(player.ultCharge>=100){
          player.ultCharge=100;
          if(player.ultCooldownTimer<=0){
            player.ultReady=true;
            showMessage("Ultimate ready!",2.2);
          }
        }
      }

      player.styleMeter-=player.styleDecayRate*dt;
      player.styleMeter=clamp(player.styleMeter,0,player.styleMax);
      const rank=getStyleRank();
      if(rank==="S" && !cosmeticStats.reachedStyleSOnce){
        cosmeticStats.reachedStyleSOnce=true;
        saveCosmeticStats();
        checkCosmeticUnlocks();
      }
    }

    /* DRAWING & HUD */

    function updateHUD(){
      if(!player){
        hudWave.textContent="";
        hudHP.textContent="";
        hudStats.textContent="";
        hudUlt.textContent="";
        hudStyle.textContent="";
        hudKills.textContent="";
        hudChallenge.textContent=`Rerolls: ${playerRerolls}`;
        return;
      }
      hudWave.textContent=`Wave ${wave||0}`;
      hudHP.textContent=`HP ${Math.round(player.hp)}/${Math.round(player.maxHp)}`;
      hudHP.classList.toggle("low",player.hp/player.maxHp<0.35);

      const dmgMult=(player.damage/BASE_STATS.damage).toFixed(2);
      const frMult=(player.fireRate/BASE_STATS.fireRate).toFixed(2);
      const spMult=(player.speed/BASE_STATS.speed).toFixed(2);
      hudStats.textContent=`DMG x${dmgMult} • Fire x${frMult} • Move x${spMult}`;

      const rank=getStyleRank();
      const stylePct=Math.round((player.styleMeter/player.styleMax)*100);
      hudStyle.textContent=`Style: ${rank} (${stylePct}%)`;
      hudStyle.classList.toggle("style-high",rank==="A"||rank==="S");

      const def=player.ultId?ULT_DEFS[player.ultId]:null;
      if(def){
        const cd=player.ultCooldownTimer>0?player.ultCooldownTimer.toFixed(1):"0.0";
        const charge=Math.round(player.ultCharge||0);
        hudUlt.textContent=`Ult: ${def.name} – ${player.ultReady?"READY":`CD ${cd}s`} • Charge ${charge}%`;
        hudUlt.classList.toggle("ult-ready",player.ultReady);
      }else{
        hudUlt.textContent="Ult: None";
        hudUlt.classList.remove("ult-ready");
      }

      hudKills.textContent=`Kills: ${runKills}`;

      // Challenge / rerolls
      if(currentChallenge && currentChallenge.active){
        if(currentChallenge.type==="no_hit"){
          hudChallenge.textContent=`Challenge: Don't get hit (active) • Rerolls: ${playerRerolls}`;
        }else if(currentChallenge.type==="kill_rush"){
          const t=Math.max(0,currentChallenge.timer).toFixed(1);
          hudChallenge.textContent=`Challenge: ${currentChallenge.kills}/${currentChallenge.targetKills} kills in ${t}s • Rerolls: ${playerRerolls}`;
        }
      }else if(currentChallenge && currentChallenge.completed){
        hudChallenge.textContent=`Challenge complete! Rerolls: ${playerRerolls}`;
      }else if(currentChallenge && currentChallenge.failed){
        hudChallenge.textContent=`Challenge failed. Rerolls: ${playerRerolls}`;
      }else{
        hudChallenge.textContent=`Rerolls: ${playerRerolls}`;
      }

      updateStatsPanel();
    }

    function drawPlayer(){
      if(!player)return;
      const theme=getPlayerSkinTheme();
      ctx.save();
      if(player.isDashing){
        ctx.globalAlpha=0.9;
        spawnParticles(player.x,player.y,{
          count:2,speedMin:30,speedMax:80,lifeMin:0.2,lifeMax:0.45,sizeMin:2,sizeMax:3,color:getDashParticleColor()
        });
      }

      ctx.beginPath();
      ctx.arc(player.x,player.y,player.radius+2,0,Math.PI*2);
      ctx.fillStyle=theme.auraColor;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(player.x,player.y,player.radius,0,Math.PI*2);
      ctx.fillStyle=theme.bodyColor;
      ctx.fill();
      ctx.lineWidth=2;
      ctx.strokeStyle=theme.outlineColor;
      ctx.stroke();

      const dx=mousePos.x-player.x;
      const dy=mousePos.y-player.y;
      const ang=Math.atan2(dy,dx);
      const wx=player.x+Math.cos(ang)*(player.radius+6);
      const wy=player.y+Math.sin(ang)*(player.radius+6);
      ctx.beginPath();
      ctx.moveTo(player.x,player.y);
      ctx.lineTo(wx,wy);
      ctx.lineWidth=3;
      ctx.strokeStyle=theme.weaponColor;
      ctx.stroke();

      if(player.meleeSwingTimer>0){
        ctx.beginPath();
        ctx.arc(player.x,player.y,player.meleeRange,player.meleeAngle-player.meleeArc/2,player.meleeAngle+player.meleeArc/2);
        ctx.strokeStyle="rgba(255,255,255,0.4)";
        ctx.lineWidth=2;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawSummons(){
      ctx.save();
      for(const s of summons){
        ctx.beginPath();
        ctx.arc(s.x,s.y,8,0,Math.PI*2);
        ctx.fillStyle="#2c203f";
        ctx.fill();
        ctx.lineWidth=2;
        ctx.strokeStyle="#9a7dff";
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawFireAndBombs(){
      ctx.save();
      for(const f of fireBursts){
        const t=f.life/0.6;
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.radius,0,Math.PI*2);
        ctx.fillStyle=`rgba(255,160,90,${t*0.6})`;
        ctx.fill();
      }
      for(const b of playerBombs){
        ctx.beginPath();
        ctx.arc(b.x,b.y,10,0,Math.PI*2);
        ctx.fillStyle=b.exploded?"rgba(255,220,160,0.35)":"rgba(200,140,80,1)";
        ctx.fill();
      }
      ctx.restore();
    }

    function drawBullets(){
      ctx.save();
      const bulletColor=getBulletColor();
      for(const b of bullets){
        ctx.beginPath();
        ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);
        ctx.fillStyle=bulletColor;
        ctx.fill();
      }
      ctx.fillStyle="#ff8080";
      for(const b of enemyBullets){
        ctx.beginPath();
        ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawEnemies(){
      ctx.save();
      for(const e of enemies){
        ctx.beginPath();
        ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
        ctx.fillStyle=e.color;
        ctx.fill();
        ctx.lineWidth=e.isBoss?3:1.5;
        ctx.strokeStyle=e.isBoss?"#ffffff":"#000000";
        ctx.stroke();

        const barW=e.radius*2;
        const barH=4;
        const hpRatio=clamp(e.hp/e.maxHp,0,1);
        const bx=e.x-barW/2;
        const by=e.y-e.radius-8;
        ctx.fillStyle="rgba(0,0,0,0.7)";
        ctx.fillRect(bx,by,barW,barH);
        ctx.fillStyle= e.isBoss?"#ffd480":"#66ff99";
        ctx.fillRect(bx,by,barW*hpRatio,barH);

        if(e.isBoss && e.bossId){
          const def=BOSS_TEMPLATES.find(b=>b.id===e.bossId);
          const name=def?def.name:e.bossId;
          ctx.font="11px system-ui";
          ctx.fillStyle="#f5f5f5";
          ctx.textAlign="center";
          ctx.fillText(name,e.x,by-4);
        }
      }
      ctx.restore();
    }

    function drawGenjutsuOverlay(){
      if(bossGenjutsuTimer<=0)return;
      const t=bossGenjutsuTimer/GENJUTSU_DURATION;
      ctx.save();
      ctx.fillStyle=`rgba(120,0,0,${0.3*t})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();
    }

    function applyScreenShake(){
      if(screenShakeTimer<=0)return;
      const t=screenShakeTimer/screenShakeDuration;
      const mag=screenShakeIntensity*t;
      const ox=(Math.random()*2-1)*mag;
      const oy=(Math.random()*2-1)*mag;
      ctx.translate(ox,oy);
    }

    function drawWhiteFlash(){
      if(whiteFlashAlpha<=0)return;
      ctx.save();
      ctx.fillStyle=`rgba(255,255,255,${whiteFlashAlpha})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();
    }

    /* GAME STATE & LOOP */

    function handleGameOver(){
      gameState="gameover";
      domainField.active=false;
      resetChallenge();
      showMessage("Game Over – press R to retry.",3);
      saveCosmeticStats();
      checkCosmeticUnlocks();
    }

    function resetGame(){
      startNewRun();
    }

    function startNewRun(){
      player=createPlayer();
      player.ultId=selectedUltId;
      player.normalAbilities=[];
      player.bossAbilities=[];
      activeCurses=[];
      summons=[];
      fireBursts.length=0;
      playerBombs.length=0;
      slowFields.length=0;
      bullets.length=0;
      enemyBullets.length=0;
      enemies.length=0;
      wave=0;
      runKills=0;
      player.mahitoTouchStacks=0;
      player.styleMeter=0;
      player.ultCharge=0;
      player.ultReady=false;
      player.ultStatsApplied=false;
      player.meleeHitApplied=false;
      screenShakeTimer=0;
      whiteFlashAlpha=0;
      bossGenjutsuTimer=0;
      currentBoss=null;
      waveActive=false;
      enemiesSpawned=false;
      upgradePending=false;
      replaceTarget=null;
      intermissionTimer=0;
      nextWavePending=false;
      nextWaveDelay=0;
      playerRerolls=0;
      resetChallenge();
      updateRerollUI();

      const arch=ARCHETYPES[selectedArchetype];
      if(arch && arch.startAbilities){
        for(const id of arch.startAbilities){
          const def=getAbilityById(id)||getCurseById(id);
          if(!def)continue;
          if(def.type==="boss")player.bossAbilities.push(id);
          else if(def.type==="curse")activeCurses.push(id);
          else player.normalAbilities.push(id);
        }
      }

      if(combatStyle==="melee"){
        player.damage*=0.9;
        player.meleeDamage*=1.25;
        player.meleeRange*=1.1;
      }else if(combatStyle==="ranged"){
        player.damage*=1.1;
        player.meleeDamage*=0.85;
      }

      recomputeStats();
      updateHUDAbilities();
      updateStatsPanel();

      mainMenu.style.display="none";
      gameState="intermission";
      intermissionTimer=1.0; // ~1 second grace before first wave
      showMessage("Get ready...",1.5);
    }

    function gameLoop(timestamp){
      if(!lastTime)lastTime=timestamp;
      const dt=Math.min((timestamp-lastTime)/1000,0.033);
      lastTime=timestamp;

      if(messageTimer>0){
        messageTimer-=dt;
        if(messageTimer<=0)overlayMessageEl.textContent="";
      }
      if(screenShakeTimer>0)screenShakeTimer-=dt;
      if(whiteFlashAlpha>0)whiteFlashAlpha-=dt*1.8;
      if(bossGenjutsuTimer>0)bossGenjutsuTimer-=dt;

      updateBackground(dt);

      if(gameState==="playing"||gameState==="intermission"||gameState==="upgrading"||gameState==="gameover"){
        runTime+=dt;
      }

      if(gameState==="playing"){
        timeInWave+=dt;
        updateChallenge(dt);
        if(waveActive && enemiesSpawned && enemies.length===0 && !upgradePending){
          waveActive=false;
          onWaveCleared();
        }
      }

      if(upgradePending){
        nextUpgradeDelayTimer-=dt;
        if(nextUpgradeDelayTimer<=0){
          upgradePending=false;
          openUpgradePanel();
        }
      }

      if(gameState==="intermission"){
        intermissionTimer-=dt;
        if(intermissionTimer<=0 && enemies.length===0 && !upgradePending){
          startNextWave();
        }
      }

      if(gameState==="playing"){
        updatePlayer(dt);
        updateSummons(dt);
        updateFireBursts(dt);
        updatePlayerBombs(dt);
        updateSlowFields(dt);
        updateEnemies(dt);
        updateBullets(dt);
      }else if(gameState==="gameover"){
        updateParticles(dt);
      }

      updateParticles(dt);
      updateDomain(dt);
      updateHUD();

      ctx.save();
      drawBackground();
      applyScreenShake();
      drawDomain();
      drawFireAndBombs();
      drawSummons();
      drawEnemies();
      drawBullets();
      drawPlayer();
      drawParticles();
      drawGenjutsuOverlay();
      drawWhiteFlash();
      ctx.restore();

      requestAnimationFrame(gameLoop);
    }

    /* MAIN MENU INIT */

    function initMainMenu(){
      const tabs={
        playTab:document.getElementById("playTab"),
        settingsTab:document.getElementById("settingsTab"),
        achievementsTab:document.getElementById("achievementsTab"),
        cosmeticsTab:document.getElementById("cosmeticsTab")
      };
      const tabButtons=document.querySelectorAll(".mainTabButton");
      tabButtons.forEach(btn=>{
        btn.addEventListener("click",()=>{
          const tabId=btn.getAttribute("data-tab");
          tabButtons.forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
          Object.keys(tabs).forEach(k=>{
            tabs[k].style.display=(k===tabId)?"block":"none";
          });
        });
      });

      document.querySelectorAll(".modeButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          document.querySelectorAll(".modeButton").forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
          difficulty=btn.getAttribute("data-mode")||"normal";
        });
      });

      document.querySelectorAll("[data-style]").forEach(btn=>{
        btn.addEventListener("click",()=>{
          document.querySelectorAll("[data-style]").forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
          combatStyle=btn.getAttribute("data-style")||"ranged";
        });
      });
      combatStyle="ranged";

      document.querySelectorAll(".archButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          document.querySelectorAll(".archButton").forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
          selectedArchetype=btn.getAttribute("data-arch")||"sorcerer";
        });
      });

      document.querySelectorAll(".ultButton").forEach(btn=>{
        btn.addEventListener("click",()=>{
          document.querySelectorAll(".ultButton").forEach(b=>b.classList.remove("styleActive"));
          btn.classList.add("styleActive");
          selectedUltId=btn.getAttribute("data-ult")||"jjk_domain";
        });
      });

      const startBtn=document.getElementById("startRunButton");
      startBtn.addEventListener("click",()=>{
        if(!combatStyle)combatStyle="ranged";
        startNewRun();
      });

      refreshAchievementsUI();
      refreshCosmeticButtons();
    }

    /* INIT */

    loadSettings();
    setupSettingsUI();
    initCosmeticsSystem();
    initMobileControls();
    initMainMenu();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
